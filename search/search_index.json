{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TLS REQUESTS","text":"<p>A powerful and lightweight Python library for making secure and reliable HTTP/TLS fingerprint requests.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Key Benefits</li> <li>Cookie Management</li> <li>Documentation</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the library, you can choose between two methods:</p>"},{"location":"#1-install-via-pypi","title":"1. Install via PyPI:","text":"<pre><code># Using pip\npip install wrapper-tls-requests\n\n# Using uv\nuv add wrapper-tls-requests\n</code></pre>"},{"location":"#2-install-via-github-repository","title":"2. Install via GitHub Repository:","text":"<pre><code>pip install git+https://github.com/thewebscraping/tls-requests.git\n</code></pre> <p>Note: After installation you can update the TLS library manually using: <code>bash python -m tls_requests.models.libraries</code></p> <p>Logging: The library now uses the standard <code>logging</code> module. Configure it in your application, e.g.: <code>python import logging logging.basicConfig(level=logging.INFO)</code></p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Start using TLS Requests with just a few lines of code:</p> <pre><code>import tls_requests\nr = tls_requests.get(\"https://httpbin.org/get\")\nr\n&lt;Response [200 OK]&gt;\nr.status_code\n200\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>TLS Requests is a cutting-edge HTTP client for Python, offering a feature-rich, highly configurable alternative to the popular <code>requests</code> library.</p> <p>It is built on top of <code>tls-client</code>, combining ease of use with advanced functionality for secure networking.</p> <p>Acknowledgment: A big thank you to all contributors for their support!</p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<ul> <li>Bypass TLS Fingerprinting: Mimic browser-like behaviors to navigate sophisticated anti-bot systems.</li> <li>Customizable TLS Clients: Select specific TLS fingerprints to meet your needs.</li> <li>Ideal for Developers: Build scrapers, API clients, or other custom networking tools effortlessly.</li> </ul>"},{"location":"#why-use-tls-requests","title":"Why Use TLS Requests?","text":"<p>Modern websites increasingly use TLS Fingerprinting and anti-bot tools like Cloudflare Bot Fight Mode to block web crawlers.</p> <p>TLS Requests bypasses these obstacles by mimicking browser-like TLS behaviors, making it easy to scrape data or interact with websites that use sophisticated anti-bot measures.</p>"},{"location":"#cloudflare-bot-fight-mode","title":"Cloudflare Bot Fight Mode","text":""},{"location":"#unlock-content-behind-cloudflare-bot-fight-mode","title":"Unlock Content Behind Cloudflare Bot Fight Mode","text":"<p>Example Code:</p> <pre><code>import tls_requests\nr = tls_requests.get('https://www.coingecko.com/')\nr\n&lt;Response [200]&gt;\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#enhanced-capabilities","title":"Enhanced Capabilities","text":"<ul> <li>Browser-like TLS Fingerprinting: Enables secure and reliable browser-mimicking connections.</li> <li>High-Performance Backend: Built on a Go-based HTTP backend for speed and efficiency.</li> <li>Synchronous &amp; Asynchronous Support: Seamlessly switch between synchronous and asynchronous requests.</li> <li>Protocol Support: Fully compatible with HTTP/1.1 and HTTP/2.</li> <li>Strict Timeouts: Reliable timeout management for precise control over request durations.</li> </ul>"},{"location":"#additional-features","title":"Additional Features","text":"<ul> <li>Internationalized Domain &amp; URL Support: Handles non-ASCII URLs effortlessly.</li> <li>Cookie Management: Ensures session-based cookie persistence.</li> <li>Authentication: Native support for Basic and Function authentication.</li> <li>Content Decoding: Automatic handling of gzip and brotli-encoded responses.</li> <li>Hooks: Perfect for logging, monitoring, tracing, or pre/post-processing requests and responses.</li> <li>Unicode Support: Effortlessly process Unicode response bodies.</li> <li>File Uploads: Simplified multipart file upload support.</li> <li>Proxy Configuration: Supports Socks5, HTTP, and HTTPS proxies for enhanced privacy.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore the full capabilities of TLS Requests in the documentation:</p> <ul> <li>Quickstart Guide: A beginner-friendly guide.</li> <li>Advanced Topics: Learn to leverage specialized features.</li> <li>Async Support: Handle high-concurrency scenarios.</li> <li>Custom TLS Configurations:<ul> <li>Wrapper TLS Client</li> <li>TLS Client Profiles</li> <li>Custom TLS Configurations</li> </ul> </li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide for TLS Requests","text":"<p>This guide provides a comprehensive overview of using the <code>tls_requests</code> Python library. Follow these examples to integrate the library efficiently into your projects.</p>"},{"location":"quickstart/#importing-tls_requests","title":"Importing <code>tls_requests</code>","text":"<p>Begin by importing the library:</p> <pre><code>import tls_requests\nimport logging\nlogging.basicConfig(level=logging.INFO)\n</code></pre>"},{"location":"quickstart/#making-http-requests","title":"Making HTTP Requests","text":""},{"location":"quickstart/#get-request","title":"GET Request","text":"<p>Fetch a webpage using a GET request:</p> <pre><code>r = tls_requests.get('https://httpbin.org/get')\nr\n&lt;Response [200 OK]&gt;\n# Cookies now have proper domain backfilled from request URL\n</code></pre>"},{"location":"quickstart/#post-request","title":"POST Request","text":"<p>Make a POST request with data:</p> <pre><code>r = tls_requests.post('https://httpbin.org/post', data={'key': 'value'})\n</code></pre>"},{"location":"quickstart/#other-http-methods","title":"Other HTTP Methods","text":"<p>Use the same syntax for PUT, DELETE, HEAD, and OPTIONS:</p> <pre><code>r = tls_requests.put('https://httpbin.org/put', data={'key': 'value'})\nr\n&lt;Response [200 OK]&gt;\nr = tls_requests.delete('https://httpbin.org/delete')\nr\n&lt;Response [200 OK]&gt;\nr = tls_requests.head('https://httpbin.org/get')\n&lt;Response [200 OK]&gt;\nr\nr = tls_requests.options('https://httpbin.org/get')\nr\n&lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"quickstart/#using-client-identifiers","title":"Using Client Identifiers","text":"<p>Specify a TLS client profile using the <code>client_identifier</code> parameter:</p> <pre><code>r = tls_requests.get('https://httpbin.org/get', client_identifier=\"chrome_120\")\n</code></pre>"},{"location":"quickstart/#http2-support","title":"HTTP/2 Support","text":"<p>Enable HTTP/2 with the <code>http2</code> parameter:</p> <pre><code>r = tls_requests.get('https://httpbin.org/get', http2=True, client_identifier=\"chrome_120\")\n</code></pre> <p>Tip</p> <ul> <li><code>http2</code> parameter:<ul> <li><code>auto</code> or <code>None</code>: Automatically switch between HTTP/2 and HTTP/1, with HTTP/2 preferred. Used in cases of redirect requests.</li> <li><code>http1</code> or <code>False</code>: Force to HTTP/1.</li> <li><code>http2</code>, <code>True</code>: Force to HTTP/2.</li> </ul> </li> </ul>"},{"location":"quickstart/#url-parameters","title":"URL Parameters","text":"<p>Pass query parameters using the <code>params</code> keyword:</p> <pre><code>import tls_requests\nparams = {'key1': 'value1', 'key2': 'value2'}\nr = tls_requests.get('https://httpbin.org/get', params=params)\nr.url\n'&lt;URL: https://httpbin.org/get?key1=value1&amp;key2=value2&gt;'\nr.url.url\n'https://httpbin.org/get'\nr.url.params\n&lt;URLParams: dict_items([('key1', 'value1'), ('key2', 'value2')])&gt;\n</code></pre> <p>Include lists or merge parameters with existing query strings:</p> <pre><code>params = {'key1': 'value1', 'key2': ['value2', 'value3']}\nr = tls_requests.get('https://httpbin.org/get?order_by=asc', params=params)\nr.url\n'&lt;URL: https://httpbin.org/get?order_by=asc&amp;key1=value1&amp;key2=value2&amp;key2=value3&gt;'\n</code></pre>"},{"location":"quickstart/#custom-headers","title":"Custom Headers","text":"<p>Add custom headers to requests:</p> <pre><code>url = 'https://httpbin.org/headers'\nheaders = {'user-agent': 'my-app/1.0.0'}\nr = tls_requests.get(url, headers=headers)\nr.json()\n{\n  \"headers\": {\n    ...\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"my-app/1.0.0\",\n    ...\n  }\n}\n</code></pre>"},{"location":"quickstart/#handling-response-content","title":"Handling Response Content","text":""},{"location":"quickstart/#text-content","title":"Text Content","text":"<p>Decode response content automatically:</p> <pre><code>r = tls_requests.get('https://httpbin.org/get')\nprint(r.text)\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\nr.encoding\n'UTF-8'\n</code></pre>"},{"location":"quickstart/#binary-content","title":"Binary Content","text":"<p>Access non-text response content:</p> <pre><code>r.content\nb'{\\n  \"args\": {}, \\n  \"headers\": {\\n    \"Accept\": \"*/*\", ...'\n</code></pre>"},{"location":"quickstart/#json-content","title":"JSON Content","text":"<p>Parse JSON responses directly:</p> <pre><code>r.json()\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#form-encoded-data","title":"Form-Encoded Data","text":"<p>Include form data in POST requests:</p> <pre><code>data = {'key1': 'value1', 'key2': 'value2'}\nr = tls_requests.post(\"https://httpbin.org/post\", data=data)\nprint(r.text)\n{\n  \"args\": {},\n  \"data\": \"key1=value1&amp;key1=value2\",\n  \"files\": {},\n  \"form\": {},\n  ...\n}\n</code></pre> <p>Form encoded data can also include multiple values from a given key.</p> <pre><code>data = {'key1': ['value1', 'value2']}\nr = tls_requests.post(\"https://httpbin.org/post\", data=data)\nprint(r.text)\n{\n  ...\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value2\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#multipart-file-uploads","title":"Multipart File Uploads","text":"<p>Upload files using <code>files</code>:</p> <pre><code>files = {'image': open('static/coingecko.png', 'rb')}\nr = tls_requests.post(\"https://httpbin.org/get\", files=files)\nprint(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  ...\n}\n</code></pre> <p>Add custom filenames or MIME types:</p> <pre><code>files = {'image': ('image.png', open('static/coingecko.png', 'rb'), 'image/*')}\nr = tls_requests.post(\"https://httpbin.org/get\", files=files)\nprint(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  ...\n}\n</code></pre> <p>If you need to include non-file data fields in the multipart form, use the <code>data=...</code> parameter:</p> <pre><code>data = {'key1': ['value1', 'value2']}\nfiles = {'image': open('static/coingecko.png', 'rb')}\nr = tls_requests.post(\"https://httpbin.org/get\", data=data, files=files)\nprint(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value1\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#json-data","title":"JSON Data","text":"<p>Send complex JSON data structures:</p> <pre><code>data = {\n    'integer': 1,\n    'boolean': True,\n    'list': ['1', '2', '3'],\n    'data': {'key': 'value'}\n}\nr = tls_requests.post(\"https://httpbin.org/post\", json=data)\nprint(r.text)\n{\n  ...\n  \"json\": {\n    \"boolean\": true,\n    \"data\": {\n      \"key\": \"value\"\n    },\n    \"integer\": 1,\n    \"list\": [\n      \"1\",\n      \"2\",\n      \"3\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#inspecting-responses","title":"Inspecting Responses","text":""},{"location":"quickstart/#status-codes","title":"Status Codes","text":"<p>Check the HTTP status code:</p> <pre><code>r = tls_requests.get('https://httpbin.org/get')\nr.status_code\n200\n</code></pre> <p>Raise exceptions for non-2xx responses:</p> <pre><code>not_found = tls_requests.get('https://httpbin.org/status/404')\nnot_found.status_code\n404\nnot_found.raise_for_status()\n</code></pre> <pre><code>Traceback (most recent call last):\n  ***\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\n  File \"***tls_requests/models/response.py\", line 184, in raise_for_status\n    raise HTTPError(\ntls_requests.exceptions.HTTPError: 404 Client Error: Not Found for url: https://httpbin.org/status/404\n</code></pre> <p>Any successful response codes will return the <code>Response</code> instance rather than raising an exception.</p> <pre><code>r = tls_requests.get('https://httpbin.org/get')\nraw = r.raise_for_status().text\nprint(raw)\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#headers","title":"Headers","text":"<p>Access headers as a dictionary:</p> <pre><code>r.headers\n&lt;Headers: {\n    'access-control-allow-credentials': 'true',\n    'access-control-allow-origin': '*',\n    'content-length': '316',\n    'content-type':\n    'application/json',\n    'date': 'Wed, 04 Dec 2024 01:31:50 GMT',\n    'server': 'gunicorn/19.9.0'\n}&gt;\n</code></pre> <p>The <code>Headers</code> data type is case-insensitive, so you can use any capitalization.</p> <pre><code>r.headers['Content-Type']\n'application/json'\n</code></pre>"},{"location":"quickstart/#cookies","title":"Cookies","text":"<p>Access cookies or include them in requests:</p> <pre><code>url = 'https://httpbin.org/cookies/set?foo=bar'\nr = tls_requests.get(url, follow_redirects=True)\nr.cookies['foo']\n'bar'\n</code></pre>"},{"location":"quickstart/#redirection-handling","title":"Redirection Handling","text":"<p>Control redirect behavior using the <code>follow_redirects</code> parameter:</p> <pre><code>redirect_url = 'https://httpbin.org/absolute-redirect/3'\nr = tls_requests.get(redirect_url, follow_redirects=False)\nr\n&lt;Response [302]&gt;\nr.history\n[]\nr.next\n&lt;Request: (GET, https://httpbin.org/absolute-redirect/2)&gt;\n</code></pre> <p>You can modify the default redirection handling with the <code>follow_redirects</code> parameter:</p> <pre><code>redirect_url = 'https://httpbin.org/absolute-redirect/3'\nr = tls_requests.get(redirect_url, follow_redirects=True)\nr.status_code\n200\nr.history\n[&lt;Response [302]&gt;, &lt;Response [302]&gt;, &lt;Response [302]&gt;]\n</code></pre> <p>The <code>history</code> property of the response can be used to inspect any followed redirects. It contains a list of any redirect responses that were followed, in the order in which they were made.</p>"},{"location":"quickstart/#timeouts","title":"Timeouts","text":"<p>Set custom timeouts:</p> <pre><code>tls_requests.get('https://github.com/', timeout=10)\n</code></pre>"},{"location":"quickstart/#authentication","title":"Authentication","text":"<p>Perform Basic Authentication:</p> <pre><code>r = tls_requests.get(\"https://httpbin.org/get\", auth=(\"admin\", \"admin\"))\n</code></pre>"},{"location":"quickstart/#exceptions","title":"Exceptions","text":"<p>Handle exceptions for network errors or invalid responses:</p> <pre><code>try:\n    r = tls_requests.get('https://httpbin.org/status/404')\n    r.raise_for_status()\nexcept tls_requests.exceptions.HTTPError as e:\n    print(e)\n</code></pre>"},{"location":"advanced/async_client/","title":"Asynchronous Support","text":"<p><code>tls_requests</code> provides full support for asynchronous HTTP requests via the <code>AsyncClient</code>. This is essential for high-concurrency workloads, long-lived connections, and integration with modern async frameworks like FastAPI.</p>"},{"location":"advanced/async_client/#why-use-async","title":"Why Use Async?","text":"<ul> <li>Concurrency: efficient handling of many simultaneous requests without the overhead of threads.</li> <li>Performance: Improved I/O throughput in data-intensive applications.</li> <li>Compatibility: Seamless integration with the Python <code>asyncio</code> ecosystem.</li> </ul>"},{"location":"advanced/async_client/#making-async-requests","title":"Making Async Requests","text":"<p>To send asynchronous requests, use the <code>AsyncClient</code> within an <code>async</code> function.</p>"},{"location":"advanced/async_client/#basic-example","title":"Basic Example","text":"<pre><code>import asyncio\nimport tls_requests\n\nasync def main():\n    async with tls_requests.AsyncClient() as client:\n        response = await client.get(\"https://httpbin.org/get\")\n        print(f\"Status: {response.status_code}\")\n        print(f\"Data: {response.json()}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced/async_client/#concurrent-requests","title":"Concurrent Requests","text":"<p>You can use <code>asyncio.gather</code> to execute multiple requests in parallel efficiently.</p> <pre><code>import asyncio\nimport tls_requests\n\nasync def fetch_url(client, url):\n    response = await client.get(url)\n    return response.status_code\n\nasync def main():\n    urls = [\n        \"https://httpbin.org/get\",\n        \"https://httpbin.org/ip\",\n        \"https://httpbin.org/user-agent\"\n    ]\n\n    async with tls_requests.AsyncClient() as client:\n        tasks = [fetch_url(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        print(f\"Results: {results}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/async_client/#key-differences-from-sync-client","title":"Key Differences from Sync Client","text":"<p>The <code>AsyncClient</code> mirrors the <code>Client</code> API but requires the <code>await</code> keyword for all network operations.</p>"},{"location":"advanced/async_client/#async-methods","title":"Async Methods","text":"<p>All request methods are coroutines:</p> <ul> <li><code>await client.get(url, ...)</code></li> <li><code>await client.post(url, ...)</code></li> <li><code>await client.put(url, ...)</code></li> <li><code>await client.patch(url, ...)</code></li> <li><code>await client.delete(url, ...)</code></li> <li><code>await client.request(method, url, ...)</code></li> </ul>"},{"location":"advanced/async_client/#lifecycle-management","title":"Lifecycle Management","text":"<p>Always use the <code>async with</code> context manager to ensure that the underlying TLS sessions are automatically closed and resources are freed.</p> <pre><code>async with tls_requests.AsyncClient() as client:\n    # do work\n    ...\n# session is closed here\n</code></pre> <pre><code>#### Manual Closing\n\nAlternatively, explicitly close the client:\n\n```python\nimport asyncio\n\nasync def fetch(url):\n    client = tls_requests.AsyncClient()\n    try:\n        response = await client.get(\"https://httpbin.org/get\")\n    finally:\n        await client.aclose()\n</code></pre> <p>By using <code>AsyncClient</code>, you can unlock the full potential of asynchronous programming in Python while enjoying the simplicity and power of TLS Requests.</p>"},{"location":"advanced/authentication/","title":"Authentication","text":"<p>This section covers how to use authentication in your requests with <code>tls_requests</code>, offering both built-in options and the flexibility to define custom mechanisms.</p>"},{"location":"advanced/authentication/#basic-authentication","title":"Basic Authentication","text":""},{"location":"advanced/authentication/#using-a-tuple-username-and-password","title":"Using a Tuple (Username and Password)","text":"<p>For basic HTTP authentication, pass a tuple <code>(username, password)</code> when initializing a <code>Client</code>. This will automatically include the credentials in the <code>Authorization</code> header for all outgoing requests:</p> <pre><code>import tls_requests\n\nclient = tls_requests.Client(auth=(\"username\", \"secret\"))\nresponse = client.get(\"https://httpbin.org/basic-auth/username/secret\")\n</code></pre>"},{"location":"advanced/authentication/#using-a-custom-function","title":"Using a Custom Function","text":"<p>To customize how authentication is handled, you can use a function that modifies the request directly:</p> <pre><code>import tls_requests\n\ndef custom_auth(request):\n    request.headers[\"X-Authorization\"] = \"123456\"\n    return request\n\nresponse = tls_requests.get(\"https://httpbin.org/headers\", auth=custom_auth)\nprint(response.request.headers[\"X-Authorization\"])  # Outputs: 123456\n</code></pre>"},{"location":"advanced/authentication/#custom-authentication","title":"Custom Authentication","text":"<p>For advanced use cases, you can define custom authentication schemes by subclassing <code>tls_requests.Auth</code> and overriding the <code>build_auth</code> method.</p>"},{"location":"advanced/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>This example demonstrates how to implement Bearer token-based authentication by adding an <code>Authorization</code> header:</p> <pre><code>import tls_requests\n\nclass BearerAuth(tls_requests.Auth):\n    def __init__(self, token):\n        self.token = token\n\n    def build_auth(self, request: tls_requests.Request) -&gt; tls_requests.Request:\n        request.headers[\"Authorization\"] = f\"Bearer {self.token}\"\n        return request\n</code></pre>"},{"location":"advanced/authentication/#usage-example","title":"Usage Example","text":"<p>To use your custom <code>BearerAuth</code> implementation:</p> <pre><code>import tls_requests\n\n# Define custom class as above\nauth = BearerAuth(token=\"your_jwt_token\")\nresponse = tls_requests.get(\"https://httpbin.org/headers\", auth=auth)\n\nprint(response.request.headers[\"Authorization\"])  # Outputs: Bearer your_jwt_token\n</code></pre> <p>With these approaches, you can integrate various authentication strategies into your <code>tls_requests</code> workflow, whether built-in or custom-designed for specific needs.</p>"},{"location":"advanced/client/","title":"Client Usage","text":"<p>The <code>Client</code> class is the primary interface for making synchronous HTTP requests with <code>tls_requests</code>. It manages persistent sessions, handles cookie storage, and allows for shared configuration across multiple requests.</p> <p>If you are familiar with the <code>requests</code> library, <code>tls_requests.Client</code> is equivalent to <code>requests.Session</code>.</p>"},{"location":"advanced/client/#why-use-the-client","title":"Why Use the Client?","text":"<p>While you can use top-level functions like <code>tls_requests.get()</code>, using a <code>Client</code> is recommended for most applications because:</p> <ul> <li>Performance: Reuses underlying TLS sessions and network connections.</li> <li>State Management: Automatically manages cookies and authentication across multiple requests.</li> <li>Consistency: Shared headers, proxies, and timeouts are applied to every request made with the client.</li> </ul>"},{"location":"advanced/client/#usage-patterns","title":"Usage Patterns","text":""},{"location":"advanced/client/#recommended-context-manager","title":"Recommended: Context Manager","text":"<p>Using the <code>with</code> statement ensures that the client is automatically closed and its native resources are freed once you are finished.</p> <pre><code>import tls_requests\n\nwith tls_requests.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response.status_code)\n</code></pre>"},{"location":"advanced/client/#manual-management","title":"Manual Management","text":"<p>If you cannot use a context manager, ensure you call <code>.close()</code> manually.</p> <pre><code>import tls_requests\n\nclient = tls_requests.Client()\nresponse = client.get(\"https://httpbin.org/get\")\n# ... do more work ...\nclient.close()\n</code></pre>"},{"location":"advanced/client/#persistent-configuration","title":"Persistent Configuration","text":"<p>You can set default values during client initialization that will apply to every subsequent request.</p> <pre><code>import tls_requests\n\n# Set global headers and a proxy\nclient = tls_requests.Client(\n    headers={\"User-Agent\": \"MyCustomBrowser/1.0\"},\n    proxy=\"http://127.0.0.1:8080\"\n)\n\n# This request will use the custom User-Agent and Proxy\nresponse = client.get(\"https://httpbin.org/headers\")\n</code></pre>"},{"location":"advanced/client/#merging-headers-and-cookies","title":"Merging Headers and Cookies","text":"<p>If you provide headers or cookies both at the client level and in an individual request, they are merged. Request-level values will override client-level values if there is a conflict.</p> <pre><code>with tls_requests.Client(headers={\"X-Client\": \"A\"}) as client:\n    # This request has both 'X-Client: A' and 'X-Request: B'\n    resp = client.get(\"https://httpbin.org/headers\", headers={\"X-Request\": \"B\"})\n</code></pre>"},{"location":"advanced/client/#request-methods","title":"Request Methods","text":"<p>The client supports all standard HTTP methods:</p> <ul> <li><code>client.get(url, **kwargs)</code></li> <li><code>client.post(url, data=..., json=..., **kwargs)</code></li> <li><code>client.put(url, **kwargs)</code></li> <li><code>client.patch(url, **kwargs)</code></li> <li><code>client.delete(url, **kwargs)</code></li> <li><code>client.head(url, **kwargs)</code></li> <li><code>client.options(url, **kwargs)</code></li> </ul> <p>For more advanced scenarios like custom authentication or request hooks, refer to the dedicated guides in the Advanced section.</p> <ul> <li>Merging Headers and Cookies:     Request-level values will override client-level values if there is a conflict.</li> </ul> <pre><code>client_headers = {'X-Auth': 'client'}\nrequest_headers = {'X-Custom': 'request'}\nwith tls_requests.Client(headers=client_headers) as client:\n    response = client.get(\"https://httpbin.org/get\", headers=request_headers)\n    print(response.request.headers['X-Auth'])  # 'client'\n    print(response.request.headers['X-Custom'])  # 'request'\n</code></pre> <ul> <li>Other parameters: Request-level options take precedence.</li> </ul> <pre><code>with tls_requests.Client(auth=('user', 'pass')) as client:\n    response = client.get(\"https://httpbin.org/get\", auth=('admin', 'adminpass'))\n    # Authorization header would be encoded 'admin:adminpass'\n</code></pre>"},{"location":"advanced/client/#advanced-request-handling","title":"Advanced Request Handling","text":"<p>For more control, explicitly build and send <code>Request</code> instances:</p> <pre><code>request = tls_requests.Request(\"GET\", \"https://httpbin.org/get\")\nwith tls_requests.Client() as client:\n    response = client.send(request)\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre> <p>To combine client- and request-level configurations:</p> <pre><code>with tls_requests.Client(headers={\"X-Client-ID\": \"ABC123\"}) as client:\n    request = client.build_request(\"GET\", \"https://httpbin.org/json\")\n    # request.headers[\"X-Client-ID\"] is present, but you can modify it\n    del request.headers[\"X-Client-ID\"]\n    response = client.send(request)\n    print(response)\n</code></pre>"},{"location":"advanced/client/#file-uploads","title":"File Uploads","text":"<p>Upload files with control over file name, content, and MIME type:</p> <pre><code>files = {'upload-file': (None, 'text content', 'text/plain')}\nresponse = tls_requests.post(\"https://httpbin.org/post\", files=files)\nprint(response.json()['form']['upload-file'])  # 'text content'\n</code></pre> <p>For further details, refer to the library's documentation.</p>"},{"location":"advanced/hooks/","title":"Event Hooks","text":"<p><code>tls_requests</code> supports event hooks, enabling you to execute custom logic during specific events in the HTTP request/response lifecycle. These hooks are ideal for logging, monitoring, tracing, or pre/post-processing requests and responses.</p>"},{"location":"advanced/hooks/#hook-types","title":"Hook Types","text":""},{"location":"advanced/hooks/#1-request-hook","title":"1. Request Hook","text":"<p>Executed after the request is fully prepared but before being sent to the network. It receives the <code>request</code> object as its only argument, allowing for inspection or final modifications.</p>"},{"location":"advanced/hooks/#2-response-hook","title":"2. Response Hook","text":"<p>Triggered after the response is received from the network but before being returned to the caller. It receives the <code>response</code> object, allowing for data processing or inspection.</p>"},{"location":"advanced/hooks/#using-hooks","title":"Using Hooks","text":"<p>Hooks are registered by providing a dictionary where keys are <code>'request'</code> or <code>'response'</code>, and values are lists of callable functions.</p>"},{"location":"advanced/hooks/#example-logging-requests-and-responses","title":"Example: Logging Requests and Responses","text":"<pre><code>import tls_requests\n\ndef log_request(request):\n    print(f\"Request event: {request.method} {request.url}\")\n\ndef log_response(response):\n    print(f\"Response event: {response.status_code} for {response.url}\")\n\n# Create a client with hooks\nclient = tls_requests.Client(hooks={\n    'request': [log_request],\n    'response': [log_response]\n})\n</code></pre>"},{"location":"advanced/hooks/#example-automatic-error-handling","title":"Example: Automatic Error Handling","text":"<p>You can use hooks to automatically raise exceptions for specific status codes:</p> <pre><code>import tls_requests\n\ndef raise_on_4xx_5xx(response):\n    response.raise_for_status()\n\nclient = tls_requests.Client(hooks={'response': [raise_on_4xx_5xx]})\n# Requests through this client will now raise errors automatically on failure\n</code></pre>"},{"location":"advanced/hooks/#managing-hooks","title":"Managing Hooks","text":""},{"location":"advanced/hooks/#during-client-initialization","title":"During Client Initialization","text":"<p>You can pass the <code>hooks</code> dictionary when creating a <code>Client</code> or <code>AsyncClient</code>:</p> <pre><code>client = tls_requests.Client(hooks={\n    'request': [log_request],\n    'response': [log_response, raise_on_4xx_5xx],\n})\n</code></pre>"},{"location":"advanced/hooks/#dynamically-updating-hooks","title":"Dynamically Updating Hooks","text":"<p>You can update hooks after a client has been initialized using the <code>.hooks</code> property:</p> <pre><code>client = tls_requests.Client()\n\n# Add a request hook\nclient.hooks['request'] = [log_request]\n\n# Add a response hook\nclient.hooks['response'] = [log_response]\n\n# Completely replace hooks\nclient.hooks = {\n    'request': [log_request],\n    'response': [raise_on_4xx_5xx],\n}\n</code></pre>"},{"location":"advanced/hooks/#with-event-hooks-you-can-modularize-cross-cutting-concerns-like-authentication-refreshes-telemetry-and-detailed-logging","title":"With event hooks, you can modularize cross-cutting concerns like authentication refreshes, telemetry, and detailed logging.","text":"<ol> <li>Access Content: Use <code>.read()</code> or <code>await .aread()</code> in asynchronous contexts to access <code>response.content</code> before returning it.</li> <li>Always Use Lists: Hooks must be registered as lists of callables, even if you are adding only one function.</li> <li>Combine Hooks: You can register multiple hooks for the same event type to handle various concerns, such as logging and error handling.</li> <li>Order Matters: Hooks are executed in the order they are registered.</li> </ol> <p>With hooks, TLS Requests provides a flexible mechanism to seamlessly integrate monitoring, logging, or custom behaviors into your HTTP workflows.</p>"},{"location":"advanced/proxies/","title":"Using Proxies","text":"<p>The <code>tls_requests</code> library supports HTTP and SOCKS proxies for routing traffic through an intermediary server. This guide explains how to configure proxies for your client or individual requests.</p>"},{"location":"advanced/proxies/#how-proxies-work","title":"How Proxies Work","text":"<p>Proxies act as intermediaries between your client and the target server. When configured, <code>tls_requests</code> routes all network traffic through the specified proxy, which then forwards it to the destination. This is useful for rotating IP addresses, bypassing regional restrictions, or debugging network traffic.</p>"},{"location":"advanced/proxies/#proxy-configuration","title":"Proxy Configuration","text":""},{"location":"advanced/proxies/#http-proxies","title":"HTTP Proxies","text":"<p>To route traffic through an HTTP proxy, specify the proxy URL in the <code>proxy</code> parameter when initializing a <code>Client</code>:</p> <pre><code>import tls_requests\n\nwith tls_requests.Client(proxy=\"http://127.0.0.1:8080\") as client:\n    response = client.get(\"https://httpbin.org/ip\")\n    print(response.json())\n</code></pre>"},{"location":"advanced/proxies/#socks-proxies","title":"SOCKS Proxies","text":"<p><code>tls_requests</code> supports SOCKS5 proxies. Use the <code>socks5://</code> scheme in the proxy URL:</p> <pre><code>import tls_requests\n\n# SOCKS5 without authentication\nclient = tls_requests.Client(proxy=\"socks5://127.0.0.1:1080\")\n\n# SOCKS5 with authentication\nclient = tls_requests.Client(proxy=\"socks5://user:pass@127.0.0.1:1080\")\n</code></pre>"},{"location":"advanced/proxies/#supported-protocols","title":"Supported Protocols","text":"<ul> <li>HTTP: <code>http://</code></li> <li>HTTPS: <code>https://</code></li> <li>SOCKS5: <code>socks5://</code></li> </ul>"},{"location":"advanced/proxies/#proxy-authentication","title":"Proxy Authentication","text":"<p>If your proxy requires a username and password, you can include them directly in the proxy URL using the standard format:</p> <pre><code>proxy_url = \"http://username:password@proxy-server.com:8080\"\nclient = tls_requests.Client(proxy=proxy_url)\n</code></pre>"},{"location":"advanced/proxies/#key-considerations","title":"Key Considerations","text":"<ul> <li>Global vs. Per-Request: While you usually set a proxy on the <code>Client</code>, you can also pass a <code>proxy</code> argument to individual request methods if needed.</li> <li>HTTPS Support: Both HTTP and SOCKS5 proxies correctly handle HTTPS traffic (using the CONNECT method for HTTP proxies).</li> <li>Format: Ensure the proxy URL is a valid string. If you have a <code>Proxy</code> object (from <code>tls_requests.models</code>), it will be automatically converted to the correct string format.</li> </ul> <p>For advanced use cases where you need to change proxies for every request, see the Rotators section.</p>"},{"location":"advanced/rotators/","title":"Using Rotators","text":"<p>The <code>tls_requests</code> library supports automatic rotation of headers, client identifiers, and proxies to make your requests appear authentic and avoid detection.</p> <p>This guide explains how rotators work and how you can customize them.</p>"},{"location":"advanced/rotators/#header-rotator","title":"Header Rotator","text":"<p>Automatic Rotation</p> <p>When you initialize a <code>Client</code> without specifying the <code>headers</code> parameter, it will not rotate by default unless you explicitly provide a <code>HeaderRotator</code>.</p> <pre><code>import tls_requests\n\n# Using HeaderRotator to rotate browser headers\nwith tls_requests.Client(headers=tls_requests.HeaderRotator()) as client:\n    # Request 1 might have Chrome headers\n    res1 = client.get(\"https://httpbin.org/headers\")\n    print(f\"Request 1 UA: {res1.json()['headers']['User-Agent']}\")\n\n    # Request 2 might have Firefox headers\n    res2 = client.get(\"https://httpbin.org/headers\")\n    print(f\"Request 2 UA: {res2.json()['headers']['User-Agent']}\")\n</code></pre> <p>How to Override the Default Behavior:</p> <ul> <li>To rotate through your own list of headers, pass a <code>list</code> of <code>dict</code>s:</li> </ul> <pre><code>my_headers = [{\"User-Agent\": \"MyBot/1.0\"}, {\"User-Agent\": \"MyBot/2.0\"}]\nclient = tls_requests.Client(headers=my_headers)\n</code></pre> <ul> <li>To use a single, static set of headers (no rotation), pass a single <code>dict</code>:</li> </ul> <pre><code>static_headers = {\"User-Agent\": \"Always-The-Same-Bot/1.0\"}\nclient = tls_requests.Client(headers=static_headers)\n</code></pre> <ul> <li>To completely disable default headers, pass <code>None</code>:</li> </ul> <pre><code># This client will not add any default headers (like User-Agent).\nclient = tls_requests.Client(headers=None)\n</code></pre>"},{"location":"advanced/rotators/#tls-client-identifier-rotator","title":"TLS Client Identifier Rotator","text":"<p>Default Behavior: Automatic Rotation</p> <p>Similar to headers, the <code>Client</code> defaults to rotating through all supported client identifier profiles (e.g., <code>chrome_120</code>, <code>firefox_120</code>, <code>safari_16_0</code>, etc.). This changes your TLS fingerprint with every request, an advanced technique to evade sophisticated anti-bot systems.</p> <pre><code>import tls_requests\n\n# This client automatically changes its TLS fingerprint for each request.\nwith tls_requests.Client(client_identifier=tls_requests.TLSIdentifierRotator()) as client:\n    # These two requests will have different TLS profiles.\n    res1 = client.get(\"https://tls.browserleaks.com/json\")\n    res2 = client.get(\"https://tls.browserleaks.com/json\")\n</code></pre> <p>How to Override the Default Behavior:</p> <ul> <li> <p>To rotate through a specific list of identifiers, pass a <code>list</code> of strings:     <code>python     my_identifiers = [\"chrome_120\", \"safari_16_0\"]     client = tls_requests.Client(client_identifier=my_identifiers)</code></p> </li> <li> <p>To use a single, static identifier, pass a string:     <code>python     client = tls_requests.Client(client_identifier=\"chrome_120\")</code></p> </li> <li>To disable rotation and use the library's single default identifier, pass <code>None</code>:     <code>python     client = tls_requests.Client(client_identifier=None)</code></li> </ul>"},{"location":"advanced/rotators/#proxy-rotator","title":"Proxy Rotator","text":"<p>Unlike headers and client identifiers, proxy rotation is not enabled by default, as the library cannot provide a list of free proxies. You must provide your own list to enable this feature.</p> <p>To enable proxy rotation, pass a list of proxy strings to the <code>proxy</code> parameter. The library will automatically use a <code>weighted</code> strategy, prioritizing proxies that perform well.</p> <pre><code>import tls_requests\n\nproxy_list = [\n    \"http://user1:pass1@proxy.example.com:8080\",\n    \"http://user2:pass2@proxy.example.com:8081\",\n    \"socks5://proxy.example.com:8082\",\n    \"proxy.example.com:8083\",  # (defaults to http)\n    \"http://user:pass@proxy.example.com:8084|1.0|US\",  # http://user:pass@host:port|weight|region\n]\n\n# Provide a list to enable proxy rotation.\nwith tls_requests.Client(proxy=proxy_list) as client:\n    response = client.get(\"https://httpbin.org/get\")\n</code></pre> <p>For more control, you can create a <code>ProxyRotator</code> instance with a specific strategy:</p> <pre><code>from tls_requests.models.rotators import ProxyRotator\n\nrotator = ProxyRotator.from_file(proxy_list, strategy=\"round_robin\")\n\nwith tls_requests.Client(proxy=rotator) as client:\n    response = client.get(\"https://httpbin.org/get\")\n</code></pre> <p>Note: The <code>Client</code> automatically provides performance feedback (success/failure, latency) to the <code>ProxyRotator</code>, making the <code>weighted</code> strategy highly effective.</p>"},{"location":"advanced/rotators/#asynchronous-support","title":"Asynchronous Support","text":"<p>All rotator features, including the smart defaults, work identically with <code>AsyncClient</code>.</p> <pre><code>import tls_requests\nimport asyncio\n\nasync def main():\n    # This async client automatically uses default header and identifier rotation.\n    async with tls_requests.AsyncClient(\n            headers=tls_requests.HeaderRotator(),\n            client_identifier=tls_requests.TLSIdentifierRotator()\n    ) as client:\n        tasks = [client.get(\"https://httpbin.org/get\") for _ in range(2)]\n        responses = await asyncio.gather(*tasks)\n\n        for i, r in enumerate(responses):\n            print(f\"Async Request {i+1} status: {r.status_code}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tls/","title":"TLS Client Internals","text":"<p>The <code>tls_requests</code> library is built as a wrapper around a high-performance native TLS implementation. While most users should interact with the <code>Client</code> or <code>AsyncClient</code> classes, this section documents the lower-level <code>TLSClient</code> interface.</p> <p>Acknowledgment</p> <p>This project utilizes the core logic from <code>bogdanfinn/tls-client</code>. We express our gratitude for their open-source contributions.</p>"},{"location":"tls/#the-tlsclient-class","title":"The TLSClient Class","text":"<p>The <code>TLSClient</code> class manages interactions with the native TLS library. It handles session management, cookie persistence, and raw HTTP request dispatching.</p> <p>The <code>TLSClient</code> functions as a singleton interface. Upon first use, it automatically locates and initializes the appropriate native binary for your operating system.</p> <pre><code>from tls_requests import TLSClient\n\n# Manual initialization (optional, usually automatic)\nTLSClient.initialize()\n</code></pre>"},{"location":"tls/#methods","title":"Methods","text":""},{"location":"tls/#get_cookiessession_id-str-url-str-dict","title":"<code>get_cookies(session_id: str, url: str) -&gt; dict</code>","text":"<p>Retrieves cookies associated with a specific session and URL.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code>: The unique identifier for the TLS session.</li> <li><code>url</code>: The URL for which cookies are requested.</li> </ul> </li> <li>Returns: A dictionary of cookies.</li> </ul> <pre><code>from tls_requests import TLSClient\n\ncookies = TLSClient.get_cookies(session_id=\"my-session-123\", url=\"https://httpbin.org\")\n</code></pre>"},{"location":"tls/#add_cookiessession_id-str-payload-dict","title":"<code>add_cookies(session_id: str, payload: dict)</code>","text":"<p>Injects cookies into a specific TLS session.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code>: The identifier for the session.</li> <li><code>payload</code>: A dictionary containing cookie data and metadata.</li> </ul> </li> </ul> <pre><code>from tls_requests import TLSClient\n\npayload = {\n    \"cookies\": [\n        {\"name\": \"session_id\", \"value\": \"xyz123\"},\n        {\"name\": \"theme\", \"value\": \"dark\"}\n    ],\n    \"sessionId\": \"my-session-123\",\n    \"url\": \"https://httpbin.org/\"\n}\nTLSClient.add_cookies(session_id=\"my-session-123\", payload=payload)\n</code></pre>"},{"location":"tls/#destroy_all-bool","title":"<code>destroy_all() -&gt; bool</code>","text":"<p>Destroys all active TLS sessions and frees associated memory in the native library.</p> <ul> <li>Returns: <code>True</code> if all sessions were successfully destroyed.</li> </ul> <pre><code>from tls_requests import TLSClient\n\nsuccess = TLSClient.destroy_all()\n</code></pre>"},{"location":"tls/#destroy_sessionsession_id-str-bool","title":"<code>destroy_session(session_id: str) -&gt; bool</code>","text":"<p>Gracefully closes and removes a specific session.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code>: The ID of the session to terminate.</li> </ul> </li> <li>Returns: <code>True</code> if the session was successfully removed.</li> </ul> <pre><code>from tls_requests import TLSClient\n\nTLSClient.destroy_session(session_id=\"my-session-123\")\n</code></pre> <ul> <li>Parameters:<ul> <li><code>session_id</code> (TLSSessionId): The identifier for the session to be destroyed.</li> </ul> </li> <li>Returns: <code>True</code> if the session was successfully destroyed, otherwise <code>False</code>.</li> </ul> <pre><code>from tls_requests import TLSClient\nTLSClient.initialize()\nsuccess = TLSClient.destroy_session(session_id=\"session123\")\n</code></pre>"},{"location":"tls/#free_memoryresponse_id-tlssessionid","title":"<code>free_memory(response_id: TLSSessionId)</code>","text":"<p>Frees memory associated with a specific response.</p> <ul> <li>Parameters:<ul> <li><code>response_id</code> (str): The identifier for the response to be freed.</li> </ul> </li> <li>Returns: None.</li> </ul> <pre><code>from tls_requests import TLSClient\nTLSClient.initialize()\nTLSClient.free_memory(response_id=\"response123\")\n</code></pre>"},{"location":"tls/#requestpayload-dict","title":"<code>request(payload: dict)</code>","text":"<p>Sends a request using the TLS library. Using TLSConfig to generate payload.</p> <ul> <li>Parameters:<ul> <li><code>payload</code> (dict): A dictionary containing the request payload (e.g., method, headers, body, etc.).</li> </ul> </li> <li>Returns: The response object from the library.</li> </ul> <pre><code>from tls_requests import TLSClient, TLSConfig\nTLSClient.initialize()\nconfig = TLSConfig(requestMethod=\"GET\", requestUrl=\"https://httpbin.org/get\")\nresponse = TLSClient.request(config.to_dict())\n</code></pre>"},{"location":"tls/#responseraw-bytes-tlsresponse","title":"<code>response(raw: bytes) -&gt; TLSResponse</code>","text":"<p>Parses a raw byte response and frees associated memory.</p> <ul> <li>Parameters:<ul> <li><code>raw</code> (bytes): The raw byte response from the TLS library.</li> </ul> </li> <li>Returns: A <code>TLSResponse</code> object.</li> </ul> <pre><code>from tls_requests import TLSClient\nTLSClient.initialize()\nparsed_response = TLSClient.response(raw_bytes)\n</code></pre>"},{"location":"tls/configuration/","title":"TLS Configuration","text":"<p>The <code>tls_requests</code> library allows for deep customization of the TLS stack. This is achieved through the <code>TLSConfig</code> and <code>CustomTLSClientConfig</code> classes.</p>"},{"location":"tls/configuration/#tlsconfig","title":"TLSConfig","text":"<p>The <code>TLSConfig</code> class provides a structured way to configure TLS-specific settings for HTTP requests. It supports features like custom headers, cookie handling, proxy configuration, and advanced TLS session options.</p>"},{"location":"tls/configuration/#example-manual-configuration","title":"Example: Manual Configuration","text":"<p>You can initialize a <code>TLSConfig</code> object to fine-tune request behavior:</p> <pre><code>import tls_requests\n\nconfig_data = {\n    \"catchPanics\": False,\n    \"followRedirects\": False,\n    \"forceHttp1\": False,\n    \"headers\": {\n        \"accept\": \"text/html,application/xhtml+xml\",\n        \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Chrome/105.0.0.0 Safari/537.36\",\n    },\n    \"insecureSkipVerify\": False,\n    \"proxyUrl\": \"\",\n    \"requestMethod\": \"GET\",\n    \"requestUrl\": \"https://httpbin.org/get\",\n    \"sessionId\": \"my-custom-session\",\n    \"timeoutSeconds\": 30,\n    \"tlsClientIdentifier\": \"chrome_120\",\n}\n\nconfig = tls_requests.TLSConfig.from_kwargs(**config_data)\n# Use the config in a request\nresponse = tls_requests.get(\"https://httpbin.org/get\", **config.to_dict())\n</code></pre>"},{"location":"tls/configuration/#custom-tls-client-configuration","title":"Custom TLS Client Configuration","text":"<p>The <code>CustomTLSClientConfig</code> class defines advanced options for emulating specific client behaviors at the protocol level. This includes ALPN, HTTP/2 settings, and JA3 fingerprints.</p>"},{"location":"tls/configuration/#advanced-example-hardening-fingerprints","title":"Advanced Example: Hardening Fingerprints","text":"<pre><code>import tls_requests\n\nadvanced_config = {\n    \"alpnProtocols\": [\"h2\", \"http/1.1\"],\n    \"certCompressionAlgo\": \"brotli\",\n    \"h2Settings\": {\n        \"HEADER_TABLE_SIZE\": 65536,\n        \"MAX_CONCURRENT_STREAMS\": 1000,\n        \"INITIAL_WINDOW_SIZE\": 6291456,\n        \"MAX_HEADER_LIST_SIZE\": 262144\n    },\n    \"ja3String\": \"771,4865-4866-4867-49195-49199-49196-49200-52393-52392,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-21,29-23-24,0\",\n    \"keyShareCurves\": [\"X25519\"],\n    \"priorityFrames\": [],\n    \"pseudoHeaderOrder\": [\n        \":method\",\n        \":authority\",\n        \":scheme\",\n        \":path\"\n    ],\n    \"supportedSignatureAlgorithms\": [\n        \"ECDSAWithP256AndSHA256\",\n        \"PSSWithSHA256\",\n        \"PKCS1WithSHA256\",\n        \"ECDSAWithP384AndSHA384\",\n        \"PSSWithSHA384\",\n        \"PKCS1WithSHA384\",\n        \"PSSWithSHA512\",\n        \"PKCS1WithSHA512\"\n    ],\n    \"supportedVersions\": [\n        \"GREASE\",\n        \"1.3\",\n        \"1.2\"\n    ]\n}\n\ncustom_config = tls_requests.CustomTLSClientConfig(**advanced_config)\n# Pass this to your TLSConfig\nconfig_obj = tls_requests.TLSConfig(customTlsClient=custom_config)\nresponse = tls_requests.get(\"https://httpbin.org/get\", **config_obj.to_dict())\n</code></pre> <p>By leveraging these configuration classes, you can achieve highly specific TLS fingerprints to match any browser or specialized client requirement.</p> <p>Note</p> <p>When using <code>CustomTLSClientConfig</code>, the <code>tlsClientIdentifier</code> parameter in TLSConfig is set to None.</p>"},{"location":"tls/configuration/#passing-request-parameters-directly","title":"Passing Request Parameters Directly","text":"<pre><code>import tls_requests\nr = tls_requests.get(\n    url = \"https://httpbin.org/get\",\n    proxy = \"http://127.0.0.1:8080\",\n    http2 = True,\n    timeout = 10.0,\n    follow_redirects = True,\n    verify = True,\n    client_identifier = \"chrome_120\",\n    **config_obj.to_dict(),\n)\nr\n&lt;Response [200 OK]&gt;\n</code></pre> <p>Note</p> <p>When using the <code>customTlsClient</code> parameter within <code>**config_obj.to_dict()</code>, the <code>client_identifier</code> parameter will not be set. Parameters such as <code>headers</code>, <code>cookies</code>, <code>proxy</code>, <code>timeout</code>, <code>verify</code>, and <code>client_identifier</code> will override the existing configuration in TLSConfig.</p>"},{"location":"tls/configuration/#client-and-asyncclient-parameters","title":"<code>Client</code> and <code>AsyncClient</code> Parameters","text":"<pre><code>import tls_requests\nclient = tls_requests.Client(\n    proxy = \"http://127.0.0.1:8080\",\n    http2 = True,\n    timeout = 10.0,\n    follow_redirects = True,\n    verify = True,\n    client_identifier = \"chrome_120\",\n    **config_obj.to_dict(),\n)\nr = client.get(url = \"https://httpbin.org/get\",)\nr\n&lt;Response [200 OK]&gt;\n</code></pre> <p>Note</p> <p>The <code>Client</code> and <code>AsyncClient</code> interfaces in <code>tls_requests</code> enable reusable and shared configurations for multiple requests, providing a more convenient and efficient approach for handling HTTP requests.</p>"},{"location":"tls/install/","title":"Installing TLS Binaries","text":"<p>The <code>tls_requests</code> library requires a native binary (<code>.so</code>, <code>.dll</code>, or <code>.dylib</code>) to handle the underlying TLS fingerprinting. The library is designed to manage these binaries automatically.</p>"},{"location":"tls/install/#automatic-management","title":"Automatic Management","text":"<p>This is the recommended approach. When you first use <code>tls_requests</code> to make a request, it will automatically detect your operating system and architecture, download the appropriate binary, and store it in the library's internal <code>bin/</code> directory.</p> <pre><code>import tls_requests\n\n# The first call will trigger the binary download if it doesn't exist\nresponse = tls_requests.get('https://httpbin.org/get')\nprint(response.status_code)\n</code></pre> <p>Note</p> <p>The binaries are cached locally. Subsequent requests will reuse the existing binary without any network overhead.</p>"},{"location":"tls/install/#manual-download","title":"Manual Download","text":"<p>If your environment has restricted internet access or if you need a specific version of the underlying <code>tls-client</code> library, you can trigger a download manually.</p> <pre><code>from tls_requests import TLSLibrary\n\n# Download a specific version\nTLSLibrary.download(version='1.13.1')\n</code></pre> <p>This ensures the binary is ready before your main application code begins execution.</p>"},{"location":"tls/install/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"tls/install/#custom-binary-path","title":"Custom Binary Path","text":"<p>You can override the automatic discovery by setting the <code>TLS_LIBRARY_PATH</code> environment variable to the absolute path of a compatible binary.</p> <pre><code>export TLS_LIBRARY_PATH=/path/to/your/custom/library.so\n</code></pre>"},{"location":"tls/install/#dependencies","title":"Dependencies","text":"<ul> <li>Python: 3.9 or higher.</li> <li>Operating Systems: Windows, macOS (Intel/Apple Silicon), and most Linux distributions (Ubuntu, Debian, CentOS, etc.).</li> <li>Architecture: x86_64 (amd64), ARM64, and others.</li> </ul> <p>For more information on the available versions, refer to the TLS Client GitHub Releases.</p>"},{"location":"tls/profiles/","title":"TLS Profiles","text":"<p><code>tls_requests</code> allows you to emulate specific browser TLS fingerprints by providing a <code>client_identifier</code>. This spoofing is handled automatically at the protocol level.</p>"},{"location":"tls/profiles/#default-client-configuration","title":"Default Client Configuration","text":"<p>By default, the <code>Client</code> and <code>AsyncClient</code> use the following settings:</p> <ul> <li>Timeout: 30 seconds.</li> <li>Default Profile: <code>chrome_133</code>.</li> <li>Redirects: Followed by default (max 9).</li> <li>HTTP/2: Enabled (Auto-negotiation).</li> <li>Verification: TLS certificate verification is enabled.</li> </ul> <pre><code>import tls_requests\n\n# Using the default profile\nresponse = tls_requests.get(\"https://httpbin.org/get\")\n\n# Using a specific profile\nresponse = tls_requests.get(\"https://httpbin.org/get\", client_identifier=\"firefox_132\")\n</code></pre>"},{"location":"tls/profiles/#supported-profiles","title":"Supported Profiles","text":"<p>Below is a list of commonly used identifiers supported by the underlying TLS engine.</p>"},{"location":"tls/profiles/#google-chrome","title":"Google Chrome","text":"<ul> <li><code>chrome_103</code> through <code>chrome_112</code></li> <li><code>chrome_116_PSK</code>, <code>chrome_116_PSK_PQ</code></li> <li><code>chrome_117</code></li> <li><code>chrome_120</code></li> <li><code>chrome_124</code></li> <li><code>chrome_131</code>, <code>chrome_131_PSK</code></li> <li><code>chrome_133</code> (Current Default)</li> </ul>"},{"location":"tls/profiles/#mozilla-firefox","title":"Mozilla Firefox","text":"<ul> <li><code>firefox_102</code>, <code>firefox_104</code>, <code>firefox_105</code>, <code>firefox_106</code>, <code>firefox_108</code></li> <li><code>firefox_110</code>, <code>firefox_117</code>, <code>firefox_120</code>, <code>firefox_123</code>, <code>firefox_132</code></li> </ul>"},{"location":"tls/profiles/#apple-safari","title":"Apple Safari","text":"<ul> <li><code>safari_15_6_1</code>, <code>safari_16_0</code></li> <li><code>safari_ios_15_5</code>, <code>safari_ios_15_6</code>, <code>safari_ios_16_0</code>, <code>safari_ios_17_0</code> (iOS)</li> <li><code>safari_ios_18_0</code> (check available version)</li> </ul>"},{"location":"tls/profiles/#opera","title":"Opera","text":"<ul> <li><code>opera_89</code>, <code>opera_90</code>, <code>opera_91</code></li> </ul>"},{"location":"tls/profiles/#mobile-specialized","title":"Mobile &amp; Specialized","text":"<ul> <li><code>zalando_ios_mobile</code>, <code>zalando_android_mobile</code></li> <li><code>nike_ios_mobile</code></li> <li><code>mms_ios</code>, <code>mms_ios_2</code>, <code>mms_ios_3</code></li> <li><code>mesh_ios</code>, <code>mesh_android</code></li> <li><code>confirmed_ios</code>, <code>confirmed_android</code></li> <li><code>cloudscraper</code></li> </ul> <p>Note</p> <p>New profiles are added frequently. If an identifier is not listed here but exists in the latest <code>tls-client</code> release, it will likely work.</p> <ul> <li>Confirmed Android 2 (<code>confirmed_android_2</code>)</li> </ul>"},{"location":"tls/profiles/#okhttp4","title":"OkHttp4","text":"<ul> <li>Android 7 (<code>okhttp4_android_7</code>)</li> <li>Android 8 (<code>okhttp4_android_8</code>)</li> <li>Android 9 (<code>okhttp4_android_9</code>)</li> <li>Android 10 (<code>okhttp4_android_10</code>)</li> <li>Android 11 (<code>okhttp4_android_11</code>)</li> <li>Android 12 (<code>okhttp4_android_12</code>)</li> <li>Android 13 (<code>okhttp4_android_13</code>)</li> </ul>"}]}