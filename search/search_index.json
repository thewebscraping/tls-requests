{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TLS REQUESTS","text":"<p>A powerful and lightweight Python library for making secure and reliable HTTP/TLS fingerprint requests.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the library, you can choose between two methods:</p>"},{"location":"#1-install-via-pypi","title":"1. Install via PyPI:","text":"<pre><code>pip install wrapper-tls-requests\n</code></pre>"},{"location":"#2-install-via-github-repository","title":"2. Install via GitHub Repository:","text":"<pre><code>pip install git+https://github.com/thewebscraping/tls-requests.git\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Start using TLS Requests with just a few lines of code:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; r = tls_requests.get(\"https://httpbin.org/get\")\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; r.status_code\n200\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>TLS Requests is a cutting-edge HTTP client for Python, offering a feature-rich, highly configurable alternative to the popular <code>requests</code> library.</p> <p>It is built on top of <code>tls-client</code>, combining ease of use with advanced functionality for secure networking.</p> <p>Acknowledgment: A big thank you to all contributors for their support!</p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<ul> <li>Bypass TLS Fingerprinting: Mimic browser-like behaviors to navigate sophisticated anti-bot systems.</li> <li>Customizable TLS Clients: Select specific TLS fingerprints to meet your needs.</li> <li>Ideal for Developers: Build scrapers, API clients, or other custom networking tools effortlessly.</li> </ul>"},{"location":"#why-use-tls-requests","title":"Why Use TLS Requests?","text":"<p>Modern websites increasingly use TLS Fingerprinting and anti-bot tools like Cloudflare Bot Fight Mode to block web crawlers.</p> <p>TLS Requests bypasses these obstacles by mimicking browser-like TLS behaviors, making it easy to scrape data or interact with websites that use sophisticated anti-bot measures.</p>"},{"location":"#cloudflare-bot-fight-mode","title":"Cloudflare Bot Fight Mode","text":""},{"location":"#unlock-content-behind-cloudflare-bot-fight-mode","title":"Unlock Content Behind Cloudflare Bot Fight Mode","text":"<p>Example Code:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; r = tls_requests.get('https://www.coingecko.com/')\n&gt;&gt;&gt; r\n&lt;Response [200]&gt;\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#enhanced-capabilities","title":"Enhanced Capabilities","text":"<ul> <li>Browser-like TLS Fingerprinting: Enables secure and reliable browser-mimicking connections.</li> <li>High-Performance Backend: Built on a Go-based HTTP backend for speed and efficiency.</li> <li>Synchronous &amp; Asynchronous Support: Seamlessly switch between synchronous and asynchronous requests.</li> <li>Protocol Support: Fully compatible with HTTP/1.1 and HTTP/2.</li> <li>Strict Timeouts: Reliable timeout management for precise control over request durations.</li> </ul>"},{"location":"#additional-features","title":"Additional Features","text":"<ul> <li>Internationalized Domain &amp; URL Support: Handles non-ASCII URLs effortlessly.</li> <li>Cookie Management: Ensures session-based cookie persistence.</li> <li>Authentication: Native support for Basic and Function authentication.</li> <li>Content Decoding: Automatic handling of gzip and brotli-encoded responses.</li> <li>Hooks: Perfect for logging, monitoring, tracing, or pre/post-processing requests and responses.</li> <li>Unicode Support: Effortlessly process Unicode response bodies.</li> <li>File Uploads: Simplified multipart file upload support.</li> <li>Proxy Configuration: Supports Socks5, HTTP, and HTTPS proxies for enhanced privacy.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Explore the full capabilities of TLS Requests in the documentation:</p> <ul> <li>Quickstart Guide: A beginner-friendly guide.</li> <li>Advanced Topics: Learn to leverage specialized features.</li> <li>Async Support: Handle high-concurrency scenarios.</li> <li>Custom TLS Configurations:<ul> <li>Wrapper TLS Client</li> <li>TLS Client Profiles</li> <li>Custom TLS Configurations</li> </ul> </li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide for TLS Requests","text":"<p>This guide provides a comprehensive overview of using the <code>tls_requests</code> Python library. Follow these examples to integrate the library efficiently into your projects.</p>"},{"location":"quickstart/#importing-tls_requests","title":"Importing <code>tls_requests</code>","text":"<p>Begin by importing the library:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n</code></pre>"},{"location":"quickstart/#making-http-requests","title":"Making HTTP Requests","text":""},{"location":"quickstart/#get-request","title":"GET Request","text":"<p>Fetch a webpage using a GET request:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get')\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"quickstart/#post-request","title":"POST Request","text":"<p>Make a POST request with data:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.post('https://httpbin.org/post', data={'key': 'value'})\n</code></pre>"},{"location":"quickstart/#other-http-methods","title":"Other HTTP Methods","text":"<p>Use the same syntax for PUT, DELETE, HEAD, and OPTIONS:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.put('https://httpbin.org/put', data={'key': 'value'})\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; r = tls_requests.delete('https://httpbin.org/delete')\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; r = tls_requests.head('https://httpbin.org/get')\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; r\n&gt;&gt;&gt; r = tls_requests.options('https://httpbin.org/get')\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"quickstart/#using-tls-client-identifiers","title":"Using TLS Client Identifiers","text":"<p>Specify a TLS client profile using the <code>tls_identifier</code> parameter:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get', tls_identifier=\"chrome_120\")\n</code></pre>"},{"location":"quickstart/#http2-support","title":"HTTP/2 Support","text":"<p>Enable HTTP/2 with the <code>http2</code> parameter:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get', http2=True, tls_identifier=\"chrome_120\")  # firefox_120\n</code></pre> <p>Tip</p> <ul> <li><code>http2</code> parameter:<ul> <li><code>auto</code> or <code>None</code>: Automatically switch between HTTP/2 and HTTP/1, with HTTP/2 preferred. Used in cases of redirect requests.</li> <li><code>http1</code> or <code>False</code>: Force to HTTP/1.</li> <li><code>http2</code>, <code>True</code>: Force to HTTP/2.</li> </ul> </li> </ul>"},{"location":"quickstart/#url-parameters","title":"URL Parameters","text":"<p>Pass query parameters using the <code>params</code> keyword:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; params = {'key1': 'value1', 'key2': 'value2'}\n&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get', params=params)\n&gt;&gt;&gt; r.url\n'&lt;URL: https://httpbin.org/get?key1=value1&amp;key2=value2&gt;'\n&gt;&gt;&gt; r.url.url\n'https://httpbin.org/get'\n&gt;&gt;&gt; r.url.params\n&lt;URLParams: dict_items([('key1', 'value1'), ('key2', 'value2')])&gt;\n</code></pre> <p>Include lists or merge parameters with existing query strings:</p> <pre><code>&gt;&gt;&gt; params = {'key1': 'value1', 'key2': ['value2', 'value3']}\n&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get?order_by=asc', params=params)\n&gt;&gt;&gt; r.url\n'&lt;URL: https://httpbin.org/get?order_by=asc&amp;key1=value1&amp;key2=value2&amp;key2=value3&gt;'\n</code></pre>"},{"location":"quickstart/#custom-headers","title":"Custom Headers","text":"<p>Add custom headers to requests:</p> <pre><code>&gt;&gt;&gt; url = 'https://httpbin.org/headers'\n&gt;&gt;&gt; headers = {'user-agent': 'my-app/1.0.0'}\n&gt;&gt;&gt; r = tls_requests.get(url, headers=headers)\n&gt;&gt;&gt; r.json()\n{\n  \"headers\": {\n    ...\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"my-app/1.0.0\",\n    ...\n  }\n}\n</code></pre>"},{"location":"quickstart/#handling-response-content","title":"Handling Response Content","text":""},{"location":"quickstart/#text-content","title":"Text Content","text":"<p>Decode response content automatically:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get')\n&gt;&gt;&gt; print(r.text)\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\n&gt;&gt;&gt; r.encoding\n'UTF-8'\n</code></pre>"},{"location":"quickstart/#binary-content","title":"Binary Content","text":"<p>Access non-text response content:</p> <pre><code>&gt;&gt;&gt; r.content\nb'{\\n  \"args\": {}, \\n  \"headers\": {\\n    \"Accept\": \"*/*\", ...'\n</code></pre>"},{"location":"quickstart/#json-content","title":"JSON Content","text":"<p>Parse JSON responses directly:</p> <pre><code>&gt;&gt;&gt; r.json()\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#form-encoded-data","title":"Form-Encoded Data","text":"<p>Include form data in POST requests:</p> <pre><code>&gt;&gt;&gt; data = {'key1': 'value1', 'key2': 'value2'}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", data=data)\n&gt;&gt;&gt; print(r.text)\n{\n  \"args\": {},\n  \"data\": \"key1=value1&amp;key1=value2\",\n  \"files\": {},\n  \"form\": {},\n  ...\n}\n</code></pre> <p>Form encoded data can also include multiple values from a given key.</p> <pre><code>&gt;&gt;&gt; data = {'key1': ['value1', 'value2']}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", data=data)\n&gt;&gt;&gt; print(r.text)\n{\n  ...\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value2\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#multipart-file-uploads","title":"Multipart File Uploads","text":"<p>Upload files using <code>files</code>:</p> <pre><code>&gt;&gt;&gt; files = {'image': open('docs.sh/static/load_library.png', 'rb')}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", files=files)\n&gt;&gt;&gt; print(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  ...\n}\n</code></pre> <p>Add custom filenames or MIME types:</p> <pre><code>&gt;&gt;&gt; files = {'image': ('image.png', open('docs.sh/static/load_library.png', 'rb'), 'image/*')}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", files=files)\n&gt;&gt;&gt; print(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  ...\n}\n</code></pre> <p>If you need to include non-file data fields in the multipart form, use the <code>data=...</code> parameter:</p> <pre><code>&gt;&gt;&gt; data = {'key1': ['value1', 'value2']}\n&gt;&gt;&gt; files = {'image': open('docs.sh/static/load_library.png', 'rb')}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", data=data, files=files)\n&gt;&gt;&gt; print(r.text)\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"image\": \"data:image/png;base64, ...\"\n  },\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value2\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#json-data","title":"JSON Data","text":"<p>Send complex JSON data structures:</p> <pre><code>&gt;&gt;&gt; data = {\n    'integer': 1,\n    'boolean': True,\n    'list': ['1', '2', '3'],\n    'data': {'key': 'value'}\n}\n&gt;&gt;&gt; r = tls_requests.post(\"https://httpbin.org/post\", json=data)\n&gt;&gt;&gt; print(r.text)\n{\n  ...\n  \"json\": {\n    \"boolean\": true,\n    \"data\": {\n      \"key\": \"value\"\n    },\n    \"integer\": 1,\n    \"list\": [\n      \"1\",\n      \"2\",\n      \"3\"\n    ]\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#inspecting-responses","title":"Inspecting Responses","text":""},{"location":"quickstart/#status-codes","title":"Status Codes","text":"<p>Check the HTTP status code:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get')\n&gt;&gt;&gt; r.status_code\n200\n</code></pre> <p>Raise exceptions for non-2xx responses:</p> <pre><code>&gt;&gt;&gt; not_found = tls_requests.get('https://httpbin.org/status/404')\n&gt;&gt;&gt; not_found.status_code\n404\n&gt;&gt;&gt; not_found.raise_for_status()\n</code></pre> <pre><code>Traceback (most recent call last):\n  ***\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\n  File \"***tls_requests/models/response.py\", line 184, in raise_for_status\n    raise HTTPError(\ntls_requests.exceptions.HTTPError: 404 Client Error: Not Found for url: https://httpbin.org/status/404\n</code></pre> <p>Any successful response codes will return the <code>Response</code> instance rather than raising an exception.</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get')\n&gt;&gt;&gt; raw = r.raise_for_status().text\n&gt;&gt;&gt; print(raw)\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Host\": \"httpbin.org\",\n    ...\n  },\n  ...\n}\n</code></pre>"},{"location":"quickstart/#headers","title":"Headers","text":"<p>Access headers as a dictionary:</p> <pre><code>&gt;&gt;&gt; r.headers\n&lt;Headers: {\n    'access-control-allow-credentials': 'true',\n    'access-control-allow-origin': '*',\n    'content-length': '316',\n    'content-type':\n    'application/json',\n    'date': 'Wed, 04 Dec 2024 01:31:50 GMT',\n    'server': 'gunicorn/19.9.0'\n}&gt;\n</code></pre> <p>The <code>Headers</code> data type is case-insensitive, so you can use any capitalization.</p> <pre><code>&gt;&gt;&gt; r.headers['Content-Type']\n'application/json'\n</code></pre>"},{"location":"quickstart/#cookies","title":"Cookies","text":"<p>Access cookies or include them in requests:</p> <pre><code>&gt;&gt;&gt; url = 'https://httpbin.org/cookies/set?foo=bar'\n&gt;&gt;&gt; r = tls_requests.get(url, follow_redirects=True)\n&gt;&gt;&gt; r.cookies['foo']\n'bar'\n</code></pre>"},{"location":"quickstart/#redirection-handling","title":"Redirection Handling","text":"<p>Control redirect behavior using the <code>follow_redirects</code> parameter:</p> <pre><code>&gt;&gt;&gt; redirect_url = 'https://httpbin.org/absolute-redirect/3'\n&gt;&gt;&gt; r = tls_requests.get(redirect_url, follow_redirects=False)\n&gt;&gt;&gt; r\n&lt;Response [302]&gt;\n&gt;&gt;&gt; r.history\n[]\n&gt;&gt;&gt; r.next\n&lt;Request: (GET, https://httpbin.org/absolute-redirect/2)&gt;\n</code></pre> <p>You can modify the default redirection handling with the <code>follow_redirects</code> parameter:</p> <pre><code>&gt;&gt;&gt; redirect_url = 'https://httpbin.org/absolute-redirect/3'\n&gt;&gt;&gt; r = tls_requests.get(redirect_url, follow_redirects=True)\n&gt;&gt;&gt; r.status_code\n200\n&gt;&gt;&gt; r.history\n[&lt;Response [302]&gt;, &lt;Response [302]&gt;, &lt;Response [302]&gt;]\n</code></pre> <p>The <code>history</code> property of the response can be used to inspect any followed redirects. It contains a list of any redirect responses that were followed, in the order in which they were made.</p>"},{"location":"quickstart/#timeouts","title":"Timeouts","text":"<p>Set custom timeouts:</p> <pre><code>&gt;&gt;&gt; tls_requests.get('https://github.com/', timeout=10)\n</code></pre>"},{"location":"quickstart/#authentication","title":"Authentication","text":"<p>Perform Basic Authentication:</p> <pre><code>&gt;&gt;&gt; r = tls_requests.get(\"https://httpbin.org/get\", auth=(\"admin\", \"admin\"))\n</code></pre>"},{"location":"quickstart/#exceptions","title":"Exceptions","text":"<p>Handle exceptions for network errors or invalid responses:</p> <pre><code>try:\n    r = tls_requests.get('https://httpbin.org/status/404')\n    r.raise_for_status()\nexcept tls_requests.exceptions.HTTPError as e:\n    print(e)\n</code></pre>"},{"location":"advanced/async_client/","title":"Async Support in TLS Requests","text":"<p>TLS Requests provides support for asynchronous HTTP requests using the <code>AsyncClient</code>. This is especially useful when working in an asynchronous environment, such as with modern web frameworks, or when you need the performance benefits of asynchronous I/O.</p>"},{"location":"advanced/async_client/#why-use-async","title":"Why Use Async?","text":"<ul> <li>Improved Performance: Async is more efficient than multi-threading for handling high concurrency workloads.</li> <li>Long-lived Connections: Useful for protocols like WebSockets or long polling.</li> <li>Framework Compatibility: Essential when integrating with async web frameworks (e.g., FastAPI, Starlette).</li> </ul> <p>Advanced usage with syntax similar to Client, refer to the Client documentation.</p>"},{"location":"advanced/async_client/#making-async-requests","title":"Making Async Requests","text":"<p>To send asynchronous HTTP requests, use the <code>AsyncClient</code>:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; async def fetch(idx, url):\n    async with tls_requests.AsyncClient() as client:\n        rand = random.uniform(0.1, 1.5)\n        start_time = time.perf_counter()\n        print(\"%s: Sleep for %.2f seconds.\" % (idx, rand))\n        await asyncio.sleep(rand)\n        response = await client.get(url)\n        end_time = time.perf_counter()\n        print(\"%s: Took: %.2f\" % (idx, (end_time - start_time)))\n        return response\n&gt;&gt;&gt; async def run(urls):\n        tasks = [asyncio.create_task(fetch(idx, url)) for idx, url in enumerate(urls)]\n        responses = await asyncio.gather(*tasks)\n        return responses\n\n&gt;&gt;&gt; start_urls = [\n    'https://httpbin.org/absolute-redirect/1',\n    'https://httpbin.org/absolute-redirect/2',\n    'https://httpbin.org/absolute-redirect/3',\n    'https://httpbin.org/absolute-redirect/4',\n    'https://httpbin.org/absolute-redirect/5',\n]\n\n\n&gt;&gt;&gt; r = asyncio.run(run(start_urls))\n&gt;&gt;&gt; r\n[&lt;Response [200]&gt;, &lt;Response [200]&gt;, &lt;Response [200]&gt;, &lt;Response [200]&gt;, &lt;Response [200]&gt;]\n</code></pre> <p>Tip</p> <p>Use IPython or Python 3.8+ with <code>python -m asyncio</code> to try this code interactively, as they support executing <code>async</code>/<code>await</code> expressions in the console.</p>"},{"location":"advanced/async_client/#key-api-differences","title":"Key API Differences","text":"<p>When using <code>AsyncClient</code>, the API methods are asynchronous and must be awaited.</p>"},{"location":"advanced/async_client/#making-requests","title":"Making Requests","text":"<p>Use <code>await</code> for all request methods:</p> <ul> <li><code>await client.get(url, ...)</code></li> <li><code>await client.post(url, ...)</code></li> <li><code>await client.put(url, ...)</code></li> <li><code>await client.patch(url, ...)</code></li> <li><code>await client.delete(url, ...)</code></li> <li><code>await client.options(url, ...)</code></li> <li><code>await client.head(url, ...)</code></li> <li><code>await client.request(method, url, ...)</code></li> <li><code>await client.send(request, ...)</code></li> </ul>"},{"location":"advanced/async_client/#managing-client-lifecycle","title":"Managing Client Lifecycle","text":""},{"location":"advanced/async_client/#context-manager","title":"Context Manager","text":"<p>For proper resource cleanup, use <code>async with</code>:</p> <pre><code>import asyncio\n\nasync def fetch(url):\n    async with tls_requests.AsyncClient() as client:\n        response = await client.get(url)\n        return response\n\nr = asyncio.run(fetch(\"https://httpbin.org/get\"))\nprint(r)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/async_client/#manual-closing","title":"Manual Closing","text":"<p>Alternatively, explicitly close the client:</p> <pre><code>import asyncio\n\nasync def fetch(url):\n    client = tls_requests.AsyncClient()\n    try:\n        response = await client.get(\"https://httpbin.org/get\")\n    finally:\n        await client.aclose()\n</code></pre> <p>By using <code>AsyncClient</code>, you can unlock the full potential of asynchronous programming in Python while enjoying the simplicity and power of TLS Requests.</p>"},{"location":"advanced/authentication/","title":"Authentication","text":"<p>This section covers how to use authentication in your requests with <code>tls_requests</code>, offering both built-in options and the flexibility to define custom mechanisms.</p>"},{"location":"advanced/authentication/#basic-authentication","title":"Basic Authentication","text":""},{"location":"advanced/authentication/#using-a-tuple-username-and-password","title":"Using a Tuple (Username and Password)","text":"<p>For basic HTTP authentication, pass a tuple <code>(username, password)</code> when initializing a <code>Client</code>. This will automatically include the credentials in the <code>Authorization</code> header for all outgoing requests:</p> <pre><code>&gt;&gt;&gt; client = tls_requests.Client(auth=(\"username\", \"secret\"))\n&gt;&gt;&gt; response = client.get(\"https://www.example.com/\")\n</code></pre>"},{"location":"advanced/authentication/#using-a-custom-function","title":"Using a Custom Function","text":"<p>To customize how authentication is handled, you can use a function that modifies the request directly:</p> <pre><code>&gt;&gt;&gt; def custom_auth(request):\n        request.headers[\"X-Authorization\"] = \"123456\"\n        return request\n\n&gt;&gt;&gt; response = tls_requests.get(\"https://httpbin.org/headers\", auth=custom_auth)\n&gt;&gt;&gt; response\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; response.request.headers[\"X-Authorization\"]\n'123456'\n&gt;&gt;&gt; response.json()[\"headers\"][\"X-Authorization\"]\n'123456'\n</code></pre>"},{"location":"advanced/authentication/#custom-authentication","title":"Custom Authentication","text":"<p>For advanced use cases, you can define custom authentication schemes by subclassing <code>tls_requests.Auth</code> and overriding the <code>build_auth</code> method.</p>"},{"location":"advanced/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>This example demonstrates how to implement Bearer token-based authentication by adding an <code>Authorization</code> header:</p> <pre><code>class BearerAuth(tls_requests.Auth):\n    def __init__(self, token):\n        self.token = token\n\n    def build_auth(self, request: tls_requests.Request) -&gt; tls_requests.Request | None:\n        request.headers[\"Authorization\"] = f\"Bearer {self.token}\"\n        return request\n</code></pre>"},{"location":"advanced/authentication/#usage-example","title":"Usage Example","text":"<p>To use your custom <code>BearerAuth</code> implementation:</p> <pre><code>&gt;&gt;&gt; auth = BearerAuth(token=\"your_jwt_token\")\n&gt;&gt;&gt; response = tls_requests.get(\"https://httpbin.org/headers\", auth=auth)\n&gt;&gt;&gt; response\n&lt;Response [200 OK]&gt;\n&gt;&gt;&gt; response.request.headers[\"Authorization\"]\n'Bearer your_jwt_token'\n&gt;&gt;&gt; response.json()[\"headers\"][\"Authorization\"]\n'Bearer your_jwt_token'\n</code></pre> <p>With these approaches, you can integrate various authentication strategies into your <code>tls_requests</code> workflow, whether built-in or custom-designed for specific needs.</p>"},{"location":"advanced/client/","title":"Client Usage","text":"<p>This guide details how to utilize the <code>tls_requests.Client</code> for efficient and advanced HTTP networking. If you're transitioning from the popular <code>requests</code> library, the <code>Client</code> in <code>tls_requests</code> provides a powerful alternative with enhanced capabilities.</p>"},{"location":"advanced/client/#why-use-a-client","title":"Why Use a Client?","text":"<p>Hint</p> <p>If you\u2019re familiar with <code>requests</code>, think of <code>tls_requests.Client()</code> as the equivalent of <code>requests.Session()</code>.</p>"},{"location":"advanced/client/#tldr","title":"TL;DR","text":"<p>Use a <code>Client</code> instance if you're doing more than one-off scripts or prototypes. It optimizes network resource usage by reusing connections, which is critical for performance when making multiple requests.</p> <p>Advantages:</p> <ul> <li>Efficient connection reuse.</li> <li>Simplified configuration sharing across requests.</li> <li>Advanced control over request behavior and customization.</li> </ul>"},{"location":"advanced/client/#recommended-usage","title":"Recommended Usage","text":""},{"location":"advanced/client/#using-a-context-manager","title":"Using a Context Manager","text":"<p>The best practice is to use a <code>Client</code> as a context manager. This ensures connections are properly cleaned up:</p> <pre><code>with tls_requests.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/client/#explicit-cleanup","title":"Explicit Cleanup","text":"<p>If not using a context manager, ensure to close the client explicitly:</p> <pre><code>client = tls_requests.Client()\ntry:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response)  # &lt;Response [200 OK]&gt;\nfinally:\n    client.close()\n</code></pre>"},{"location":"advanced/client/#making-requests","title":"Making Requests","text":"<p>A <code>Client</code> can send requests using methods like <code>.get()</code>, <code>.post()</code>, etc.:</p> <pre><code>with tls_requests.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/client/#custom-headers","title":"Custom Headers","text":"<p>To include custom headers in a request:</p> <pre><code>headers = {'X-Custom': 'value'}\nwith tls_requests.Client() as client:\n    response = client.get(\"https://httpbin.org/get\", headers=headers)\n    print(response.request.headers['X-Custom'])  # 'value'\n</code></pre>"},{"location":"advanced/client/#sharing-configuration-across-requests","title":"Sharing Configuration Across Requests","text":"<p>You can apply default configurations, such as headers, for all requests made with the <code>Client</code>:</p> <pre><code>headers = {'user-agent': 'my-app/1.0'}\nwith tls_requests.Client(headers=headers) as client:\n    response = client.get(\"https://httpbin.org/headers\")\n    print(response.json()['headers']['User-Agent'])  # 'my-app/1.0'\n</code></pre>"},{"location":"advanced/client/#merging-configurations","title":"Merging Configurations","text":"<p>When client-level and request-level options overlap:</p> <ul> <li>Headers, query parameters, cookies: Combined. Example:</li> </ul> <pre><code>client_headers = {'X-Auth': 'client'}\nrequest_headers = {'X-Custom': 'request'}\nwith tls_requests.Client(headers=client_headers) as client:\n    response = client.get(\"https://httpbin.org/get\", headers=request_headers)\n    print(response.request.headers['X-Auth'])  # 'client'\n    print(response.request.headers['X-Custom'])  # 'request'\n</code></pre> <ul> <li>Other parameters: Request-level options take precedence.</li> </ul> <pre><code>with tls_requests.Client(auth=('user', 'pass')) as client:\n    response = client.get(\"https://httpbin.org/get\", auth=('admin', 'adminpass'))\n    print(response.request.headers['Authorization'])  # Encoded 'admin:adminpass'\n</code></pre>"},{"location":"advanced/client/#advanced-request-handling","title":"Advanced Request Handling","text":"<p>For more control, explicitly build and send <code>Request</code> instances:</p> <pre><code>request = tls_requests.Request(\"GET\", \"https://httpbin.org/get\")\nwith tls_requests.Client() as client:\n    response = client.send(request)\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre> <p>To combine client- and request-level configurations:</p> <pre><code>with tls_requests.Client(headers={\"X-Client-ID\": \"ABC123\"}) as client:\n    request = client.build_request(\"GET\", \"https://httpbin.org/json\")\n    del request.headers[\"X-Client-ID\"]  # Modify as needed\n    response = client.send(request)\n    print(response)\n</code></pre>"},{"location":"advanced/client/#file-uploads","title":"File Uploads","text":"<p>Upload files with control over file name, content, and MIME type:</p> <pre><code>files = {'upload-file': (None, 'text content', 'text/plain')}\nresponse = tls_requests.post(\"https://httpbin.org/post\", files=files)\nprint(response.json()['form']['upload-file'])  # 'text content'\n</code></pre> <p>For further details, refer to the library's documentation.</p>"},{"location":"advanced/hooks/","title":"Hooks","text":"<p>TLS Requests supports hooks, enabling you to execute custom logic during specific events in the HTTP request/response lifecycle. These hooks are perfect for logging, monitoring, tracing, or pre/post-processing requests and responses.</p>"},{"location":"advanced/hooks/#hook-types","title":"Hook Types","text":""},{"location":"advanced/hooks/#1-request-hook","title":"1. Request Hook","text":"<p>Executed after the request is fully prepared but before being sent to the network. It receives the <code>request</code> object, enabling inspection or modification.</p>"},{"location":"advanced/hooks/#2-response-hook","title":"2. Response Hook","text":"<p>Triggered after the response is fetched from the network but before being returned to the caller. It receives the <code>response</code> object, allowing inspection or processing.</p>"},{"location":"advanced/hooks/#setting-up-hooks","title":"Setting Up Hooks","text":"<p>Hooks are registered by providing a dictionary with keys <code>'request'</code> and/or <code>'response'</code>, and their values are lists of callable functions.</p>"},{"location":"advanced/hooks/#example-1-logging-requests-and-responses","title":"Example 1: Logging Requests and Responses","text":"<pre><code>def log_request(request):\n    print(f\"Request event hook: {request.method} {request.url} - Waiting for response\")\n\ndef log_response(response):\n    request = response.request\n    print(f\"Response event hook: {request.method} {request.url} - Status {response.status_code}\")\n\nclient = tls_requests.Client(hooks={'request': [log_request], 'response': [log_response]})\n</code></pre>"},{"location":"advanced/hooks/#example-2-raising-errors-on-4xx-and-5xx-responses","title":"Example 2: Raising Errors on 4xx and 5xx Responses","text":"<pre><code>def raise_on_4xx_5xx(response):\n    response.raise_for_status()\n\nclient = tls_requests.Client(hooks={'response': [raise_on_4xx_5xx]})\n</code></pre>"},{"location":"advanced/hooks/#example-3-adding-a-timestamp-header-to-requests","title":"Example 3: Adding a Timestamp Header to Requests","text":"<pre><code>import datetime\n\ndef add_timestamp(request):\n    request.headers['x-request-timestamp'] = datetime.datetime.utcnow().isoformat()\n\nclient = tls_requests.Client(hooks={'request': [add_timestamp]})\nresponse = client.get('https://httpbin.org/get')\nprint(response.text)\n</code></pre>"},{"location":"advanced/hooks/#managing-hooks","title":"Managing Hooks","text":""},{"location":"advanced/hooks/#setting-hooks-during-client-initialization","title":"Setting Hooks During Client Initialization","text":"<p>Provide a dictionary of hooks when creating the client:</p> <pre><code>client = tls_requests.Client(hooks={\n    'request': [log_request],\n    'response': [log_response, raise_on_4xx_5xx],\n})\n</code></pre>"},{"location":"advanced/hooks/#dynamically-updating-hooks","title":"Dynamically Updating Hooks","text":"<p>Use the <code>.hooks</code> property to inspect or modify hooks after the client is created:</p> <pre><code>client = tls_requests.Client()\n\n# Add hooks\nclient.hooks['request'] = [log_request]\nclient.hooks['response'] = [log_response]\n\n# Replace hooks\nclient.hooks = {\n    'request': [log_request],\n    'response': [log_response, raise_on_4xx_5xx],\n}\n</code></pre>"},{"location":"advanced/hooks/#best-practices","title":"Best Practices","text":"<ol> <li>Access Content: Use <code>.read()</code> or <code>await .aread()</code> in asynchronous contexts to access <code>response.content</code> before returning it.</li> <li>Always Use Lists: Hooks must be registered as lists of callables, even if you are adding only one function.</li> <li>Combine Hooks: You can register multiple hooks for the same event type to handle various concerns, such as logging and error handling.</li> <li>Order Matters: Hooks are executed in the order they are registered.</li> </ol> <p>With hooks, TLS Requests provides a flexible mechanism to seamlessly integrate monitoring, logging, or custom behaviors into your HTTP workflows.</p>"},{"location":"advanced/proxies/","title":"Using Proxies","text":"<p>The <code>tls_requests</code> library supports HTTP and SOCKS proxies for routing traffic through an intermediary server. This guide explains how to configure proxies for your client or individual requests.</p>"},{"location":"advanced/proxies/#how-proxies-work","title":"How Proxies Work","text":"<p>Proxies act as intermediaries between your client and the target server, handling requests and responses on your behalf. They can provide features like anonymity, filtering, or traffic logging.</p>"},{"location":"advanced/proxies/#http-proxies","title":"HTTP Proxies","text":"<p>To route traffic through an HTTP proxy, specify the proxy URL in the <code>proxy</code> parameter during client initialization:</p> <pre><code>with tls_requests.Client(proxy=\"http://localhost:8030\") as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/proxies/#socks-proxies","title":"SOCKS Proxies","text":"<p>For SOCKS proxies, use the <code>socks5</code> scheme in the proxy URL:</p> <pre><code>client = tls_requests.Client(proxy=\"socks5://user:pass@host:port\")\nresponse = client.get(\"https://httpbin.org/get\")\nprint(response)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/proxies/#supported-protocols","title":"Supported Protocols:","text":"<ul> <li>HTTP: Use the <code>http://</code> scheme.</li> <li>HTTPS: Use the <code>https://</code> scheme.</li> <li>SOCKS5: Use the <code>socks5://</code> scheme.</li> </ul>"},{"location":"advanced/proxies/#proxy-authentication","title":"Proxy Authentication","text":"<p>You can include proxy credentials in the <code>userinfo</code> section of the URL:</p> <pre><code>with tls_requests.Client(proxy=\"http://username:password@localhost:8030\") as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response)  # &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"advanced/proxies/#key-notes","title":"Key Notes:","text":"<ul> <li>HTTPS Support: Both HTTP and SOCKS proxies work for HTTPS requests.</li> <li>Performance: Using a proxy may slightly impact performance due to the additional routing layer.</li> <li>Security: Ensure proxy credentials and configurations are handled securely to prevent data leaks.</li> </ul>"},{"location":"tls/","title":"TLS-Client Documentation","text":"<p>Acknowledgment</p> <p>Special thanks to <code>bogdanfinn</code>. For more details, visit the GitHub repository or explore the documentation.</p>"},{"location":"tls/#wrapper-tls-client","title":"Wrapper TLS Client","text":"<p>The <code>TLSClient</code> class is a utility for managing and interacting with TLS sessions using a native library. It provides methods to handle cookies, sessions, and make HTTP requests with advanced TLS configurations.</p> <p>The TLSClient class is designed to be used as a singleton-like interface. Upon first instantiation, the class initializes the underlying native TLS library and sets up method bindings.</p> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n</code></pre> <p>Note</p> <p>The first time you initialize the TLSClient class, it will automatically find and load the appropriate library for your machine.</p>"},{"location":"tls/#methods","title":"Methods","text":""},{"location":"tls/#setup","title":"<code>setup()</code>","text":"<p>Initializes the native TLS library and binds its functions to the class methods.</p> <ul> <li>Purpose: Sets up the library functions and their argument/return types for use in other methods.</li> <li>Usage: This is automatically called when the class is first instantiated.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; client = TLSClient.initialize()\n</code></pre>"},{"location":"tls/#get_cookiessession_id-tlssessionid-url-str-dict","title":"<code>get_cookies(session_id: TLSSessionId, url: str) -&gt; dict</code>","text":"<p>Retrieves cookies associated with a session for a specific URL.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code> (TLSSessionId): The identifier for the TLS session.</li> <li><code>url</code> (str): The URL for which cookies are requested.</li> </ul> </li> <li>Returns: A dictionary of cookies.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; cookies = TLSClient.get_cookies(session_id=\"session123\", url=\"https://httpbin.org/get\")\n</code></pre>"},{"location":"tls/#add_cookiessession_id-tlssessionid-payload-dict","title":"<code>add_cookies(session_id: TLSSessionId, payload: dict)</code>","text":"<p>Adds cookies to a specific TLS session.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code> (TLSSessionId): The identifier for the TLS session.</li> <li><code>payload</code> (dict): A dictionary containing cookies to be added.</li> </ul> </li> <li>Returns: The response object from the library.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; payload = {\n    \"cookies\": [{\n        \"_name\": \"foo2\",\n        \"value\": \"bar2\",\n    },{\n        \"_name\": \"bar2\",\n        \"value\": \"baz2\",\n    }],\n    \"sessionId\": \"session123\",\n    \"url\": \"https://httpbin.org/\",\n}\n&gt;&gt;&gt; TLSClient.add_cookies(session_id=\"session123\", payload=payload)\n</code></pre>"},{"location":"tls/#destroy_all-bool","title":"<code>destroy_all() -&gt; bool</code>","text":"<p>Destroys all active TLS sessions.</p> <ul> <li>Returns: <code>True</code> if all sessions were successfully destroyed, otherwise <code>False</code>.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; success = TLSClient.destroy_all()\n</code></pre>"},{"location":"tls/#destroy_sessionsession_id-tlssessionid-bool","title":"<code>destroy_session(session_id: TLSSessionId) -&gt; bool</code>","text":"<p>Destroys a specific TLS session.</p> <ul> <li>Parameters:<ul> <li><code>session_id</code> (TLSSessionId): The identifier for the session to be destroyed.</li> </ul> </li> <li>Returns: <code>True</code> if the session was successfully destroyed, otherwise <code>False</code>.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\nsuccess = TLSClient.destroy_session(session_id=\"session123\")\n</code></pre>"},{"location":"tls/#free_memoryresponse_id-tlssessionid","title":"<code>free_memory(response_id: TLSSessionId)</code>","text":"<p>Frees memory associated with a specific response.</p> <ul> <li>Parameters:<ul> <li><code>response_id</code> (str): The identifier for the response to be freed.</li> </ul> </li> <li>Returns: None.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; TLSClient.free_memory(response_id=\"response123\")\n</code></pre>"},{"location":"tls/#requestpayload-dict","title":"<code>request(payload: dict)</code>","text":"<p>Sends a request using the TLS library. Using TLSConfig to generate payload.</p> <ul> <li>Parameters:<ul> <li><code>payload</code> (dict): A dictionary containing the request payload (e.g., method, headers, body, etc.).</li> </ul> </li> <li>Returns: The response object from the library.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient, TLSConfig\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; config = TLSConfig(requestMethod=\"GET\", requestUrl=\"https://httpbin.org/get\")\n&gt;&gt;&gt; response = TLSClient.request(config.to_dict())\n</code></pre>"},{"location":"tls/#responseraw-bytes-tlsresponse","title":"<code>response(raw: bytes) -&gt; TLSResponse</code>","text":"<p>Parses a raw byte response and frees associated memory.</p> <ul> <li>Parameters:<ul> <li><code>raw</code> (bytes): The raw byte response from the TLS library.</li> </ul> </li> <li>Returns: A <code>TLSResponse</code> object.</li> </ul> <pre><code>&gt;&gt;&gt; from tls_requests import TLSClient\n&gt;&gt;&gt; TLSClient.initialize()\n&gt;&gt;&gt; parsed_response = TLSClient.response(raw_bytes)\n</code></pre>"},{"location":"tls/configuration/","title":"Custom TLS Client Configs","text":"<p>To use custom TLS Client configuration follow these instructions:</p>"},{"location":"tls/configuration/#default-tls-config","title":"Default TLS Config","text":"<p>The <code>TLSConfig</code> class provides a structured and flexible way to configure TLS-specific settings for HTTP requests. It supports features like custom headers, cookie handling, proxy configuration, and advanced TLS options.</p> <p>Example:     Initialize a <code>TLSConfig</code> object using predefined or default settings:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; kwargs = {\n    \"catchPanics\": false,\n    \"certificatePinningHosts\": {},\n    \"customTlsClient\": {},\n    \"followRedirects\": false,\n    \"forceHttp1\": false,\n    \"headerOrder\": [\n        \"accept\",\n        \"user-agent\",\n        \"accept-encoding\",\n        \"accept-language\"\n    ],\n    \"headers\": {\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7\"\n    },\n    \"insecureSkipVerify\": false,\n    \"isByteRequest\": false,\n    \"isRotatingProxy\": false,\n    \"proxyUrl\": \"\",\n    \"requestBody\": \"\",\n    \"requestCookies\": [\n        {\n            \"_name\": \"foo\",\n            \"value\": \"bar\",\n        },\n        {\n            \"_name\": \"bar\",\n            \"value\": \"foo\",\n        },\n    ],\n    \"requestMethod\": \"GET\",\n    \"requestUrl\": \"https://microsoft.com\",\n    \"sessionId\": \"2my-session-id\",\n    \"timeoutSeconds\": 30,\n    \"tlsClientIdentifier\": \"chrome_120\",\n    \"withDebug\": false,\n    \"withDefaultCookieJar\": false,\n    \"withRandomTLSExtensionOrder\": false,\n    \"withoutCookieJar\": false\n}\n&gt;&gt;&gt; obj = tls_requests.tls.TLSConfig.from_kwargs(**kwargs)\n&gt;&gt;&gt; config_kwargs = obj.to_dict()\n&gt;&gt;&gt; r = tls_requests.get(\"https://httpbin.org/get\", **config_kwargs)\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"tls/configuration/#custom-tls-client-configuration","title":"Custom TLS Client Configuration","text":"<p>The <code>CustomTLSClientConfig</code> class defines advanced configuration options for customizing TLS client behavior. It includes support for ALPN, ALPS protocols, certificate compression, HTTP/2 settings, JA3 fingerprints, and other TLS-related settings.</p> <p>Example:     Create a <code>CustomTLSClientConfig</code> instance with specific settings:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; kwargs = {\n    \"alpnProtocols\": [\n        \"h2\",\n        \"http/1.1\"\n    ],\n    \"alpsProtocols\": [\n        \"h2\"\n    ],\n    \"certCompressionAlgo\": \"brotli\",\n    \"connectionFlow\": 15663105,\n    \"h2Settings\": {\n        \"HEADER_TABLE_SIZE\": 65536,\n        \"MAX_CONCURRENT_STREAMS\": 1000,\n        \"INITIAL_WINDOW_SIZE\": 6291456,\n        \"MAX_HEADER_LIST_SIZE\": 262144\n    },\n    \"h2SettingsOrder\": [\n        \"HEADER_TABLE_SIZE\",\n        \"MAX_CONCURRENT_STREAMS\",\n        \"INITIAL_WINDOW_SIZE\",\n        \"MAX_HEADER_LIST_SIZE\"\n    ],\n    \"headerPriority\": null,\n    \"ja3String\": \"771,2570-4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,2570-0-23-65281-10-11-35-16-5-13-18-51-45-43-27-17513-2570-21,2570-29-23-24,0\",\n    \"keyShareCurves\": [\n        \"GREASE\",\n        \"X25519\"\n    ],\n    \"priorityFrames\": [],\n    \"pseudoHeaderOrder\": [\n        \":method\",\n        \":authority\",\n        \":scheme\",\n        \":path\"\n    ],\n    \"supportedSignatureAlgorithms\": [\n        \"ECDSAWithP256AndSHA256\",\n        \"PSSWithSHA256\",\n        \"PKCS1WithSHA256\",\n        \"ECDSAWithP384AndSHA384\",\n        \"PSSWithSHA384\",\n        \"PKCS1WithSHA384\",\n        \"PSSWithSHA512\",\n        \"PKCS1WithSHA512\"\n    ],\n    \"supportedVersions\": [\n        \"GREASE\",\n        \"1.3\",\n        \"1.2\"\n    ]\n}\n&gt;&gt;&gt; custom_tls_client = tls_requests.tls.CustomTLSClientConfig.from_kwargs(**kwargs)\n&gt;&gt;&gt; config_obj = tls_requests.tls.TLSConfig(customTlsClient=custom_tls_client, tlsClientIdentifier=None)\n&gt;&gt;&gt; config_kwargs = config_obj.to_dict()\n&gt;&gt;&gt; r = tls_requests.get(\"https://httpbin.org/get\", **config_kwargs)\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre> <p>Note</p> <p>When using <code>CustomTLSClientConfig</code>, the <code>tlsClientIdentifier</code> parameter in TLSConfig is set to None.</p>"},{"location":"tls/configuration/#passing-request-parameters-directly","title":"Passing Request Parameters Directly","text":"<pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; r = tls_requests.get(\n        url = \"https://httpbin.org/get\",\n        proxy = \"https://abc:123456@127.0.0.1:8080\",\n        http2 = True,\n        timeout = 10.0,\n        follow_redirects = True,\n        verify = True,\n        tls_identifier = \"chrome_120\",\n        **config,\n    )\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre> <p>Note</p> <p>When using the <code>customTlsClient</code> parameter within <code>**config</code>, the <code>tls_identifier</code> parameter will not be set. Parameters such as <code>headers</code>, <code>cookies</code>, <code>proxy</code>, <code>timeout</code>, <code>verify</code>, and <code>tls_identifier</code> will override the existing configuration in TLSConfig.</p>"},{"location":"tls/configuration/#client-and-asyncclient-parameters","title":"<code>Client</code> and <code>AsyncClient</code> Parameters","text":"<pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; client = tls_requests.Client(\n        proxy = \"https://abc:123456@127.0.0.1:8080\",\n        http2 = True,\n        timeout = 10.0,\n        follow_redirects = True,\n        verify = True,\n        tls_identifier = \"chrome_120\",\n        **config,\n    )\n&gt;&gt;&gt; r = client.get(url = \"https://httpbin.org/get\",)\n&gt;&gt;&gt; r\n&lt;Response [200 OK]&gt;\n</code></pre> <p>Note</p> <p>The <code>Client</code> and <code>AsyncClient</code> interfaces in <code>tls_requests</code> enable reusable and shared configurations for multiple requests, providing a more convenient and efficient approach for handling HTTP requests.</p>"},{"location":"tls/install/","title":"Install","text":""},{"location":"tls/install/#auto-download","title":"Auto Download","text":"<p>This approach simplifies usage as it automatically detects your OS and downloads the appropriate version of the library. To use it:</p> <pre><code>&gt;&gt;&gt; import tls_requests\n&gt;&gt;&gt; r = tls_requests.get('https://httpbin.org/get')\n</code></pre> <p>!!! note:     The library takes care of downloading necessary files and stores them in the <code>tls_requests/bin</code> directory.</p>"},{"location":"tls/install/#manual-download","title":"Manual Download","text":"<p>If you want more control, such as selecting a specific version of the library, you can use the manual method:</p> <pre><code>&gt;&gt;&gt; from tls_requests.models.libraries import TLSLibrary\n&gt;&gt;&gt; TLSLibrary.download('1.7.10')\n</code></pre> <p>This method is useful if you need to ensure compatibility with specific library versions.</p>"},{"location":"tls/install/#notes","title":"Notes","text":"<ol> <li>Dependencies: Ensure Python is installed and configured correctly in your environment.</li> <li>Custom Directory: If needed, the library\u2019s downloaded binaries can be relocated manually to suit specific project structures.</li> <li>Reference: TLS Client GitHub Releases provides details about available versions and updates.</li> </ol>"},{"location":"tls/profiles/","title":"TLS Client Profiles","text":""},{"location":"tls/profiles/#default-tls-configuration","title":"Default TLS Configuration","text":"<p>When initializing a <code>Client</code> or <code>AsyncClient</code>, a <code>TLSClient</code> instance is created with the following default settings:</p> <ul> <li>Timeout: 30 seconds.</li> <li>Profile: Chrome 120.</li> <li>Random TLS Extension Order: Enabled.</li> <li>Redirects: Always <code>False</code>.</li> <li>Idle Connection Closure: After 90 seconds.</li> <li>Session ID: Auto generate V4 UUID string if set to None.</li> <li>Force HTTP/1.1: Default <code>False</code>.</li> </ul> <p>All requests use <code>Bogdanfinn's TLS-Client</code> to spoof the TLS client fingerprint. This process is automatic and transparent to the user.</p> <pre><code>import tls_requests\nr = tls_requests.get(\"https://httpbin.org/get\", tls_identifier=\"chrome_120\")\nprint(r)  # Output: &lt;Response [200 OK]&gt;\n</code></pre>"},{"location":"tls/profiles/#supported-client-profiles","title":"Supported Client Profiles","text":""},{"location":"tls/profiles/#internal-profiles","title":"Internal Profiles","text":""},{"location":"tls/profiles/#chrome","title":"Chrome","text":"<ul> <li>103 (<code>chrome_103</code>)</li> <li>104 (<code>chrome_104</code>)</li> <li>105 (<code>chrome_105</code>)</li> <li>106 (<code>chrome_106</code>)</li> <li>107 (<code>chrome_107</code>)</li> <li>108 (<code>chrome_108</code>)</li> <li>109 (<code>chrome_109</code>)</li> <li>110 (<code>chrome_110</code>)</li> <li>111 (<code>chrome_111</code>)</li> <li>112 (<code>chrome_112</code>)</li> <li>116 with PSK (<code>chrome_116_PSK</code>)</li> <li>116 with PSK and PQ (<code>chrome_116_PSK_PQ</code>)</li> <li>117 (<code>chrome_117</code>)</li> <li>120 (<code>chrome_120</code>)</li> <li>124 (<code>chrome_124</code>)</li> <li>131 (<code>chrome_131</code>)</li> <li>131 with PSK (<code>chrome_131_PSK</code>)</li> </ul>"},{"location":"tls/profiles/#safari","title":"Safari","text":"<ul> <li>15.6.1 (<code>safari_15_6_1</code>)</li> <li>16.0 (<code>safari_16_0</code>)</li> </ul>"},{"location":"tls/profiles/#ios-safari","title":"iOS (Safari)","text":"<ul> <li>15.5 (<code>safari_ios_15_5</code>)</li> <li>15.6 (<code>safari_ios_15_6</code>)</li> <li>16.0 (<code>safari_ios_16_0</code>)</li> <li>17.0 (<code>safari_ios_17_0</code>)</li> </ul>"},{"location":"tls/profiles/#ipados-safari","title":"iPadOS (Safari)","text":"<ul> <li>15.6 (<code>safari_ios_15_6</code>)</li> </ul>"},{"location":"tls/profiles/#firefox","title":"Firefox","text":"<ul> <li>102 (<code>firefox_102</code>)</li> <li>104 (<code>firefox_104</code>)</li> <li>105 (<code>firefox_105</code>)</li> <li>106 (<code>firefox_106</code>)</li> <li>108 (<code>firefox_108</code>)</li> <li>110 (<code>firefox_110</code>)</li> <li>117 (<code>firefox_117</code>)</li> <li>120 (<code>firefox_120</code>)</li> <li>123 (<code>firefox_123</code>)</li> <li>132 (<code>firefox_132</code>)</li> </ul>"},{"location":"tls/profiles/#opera","title":"Opera","text":"<ul> <li>89 (<code>opera_89</code>)</li> <li>90 (<code>opera_90</code>)</li> <li>91 (<code>opera_91</code>)</li> </ul>"},{"location":"tls/profiles/#custom-profiles","title":"Custom Profiles","text":"<ul> <li>Zalando iOS Mobile (<code>zalando_ios_mobile</code>)</li> <li>Nike iOS Mobile (<code>nike_ios_mobile</code>)</li> <li>Cloudscraper</li> <li>MMS iOS (<code>mms_ios</code> or <code>mms_ios_1</code>)</li> <li>MMS iOS 2 (<code>mms_ios_2</code>)</li> <li>MMS iOS 3 (<code>mms_ios_3</code>)</li> <li>Mesh iOS (<code>mesh_ios</code> or <code>mesh_ios_1</code>)</li> <li>Mesh Android (<code>mesh_android</code> or <code>mesh_android_1</code>)</li> <li>Mesh Android 2 (<code>mesh_android_2</code>)</li> <li>Confirmed iOS (<code>confirmed_ios</code>)</li> <li>Zalando Android Mobile (<code>zalando_android_mobile</code>)</li> <li>Confirmed Android (<code>confirmed_android</code>)</li> <li>Confirmed Android 2 (<code>confirmed_android_2</code>)</li> </ul>"},{"location":"tls/profiles/#okhttp4","title":"OkHttp4","text":"<ul> <li>Android 7 (<code>okhttp4_android_7</code>)</li> <li>Android 8 (<code>okhttp4_android_8</code>)</li> <li>Android 9 (<code>okhttp4_android_9</code>)</li> <li>Android 10 (<code>okhttp4_android_10</code>)</li> <li>Android 11 (<code>okhttp4_android_11</code>)</li> <li>Android 12 (<code>okhttp4_android_12</code>)</li> <li>Android 13 (<code>okhttp4_android_13</code>)</li> </ul>"}]}